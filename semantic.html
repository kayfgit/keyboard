<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Universal Chord Keyboard</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg-deep: #05080a;
    --bg-panel: #0a0e12;
    --bg-surface: #0f1419;
    --border: #1a2332;
    --border-glow: #2a3a4a;

    --text-dim: #3a4a5a;
    --text-mid: #6a7a8a;
    --text-bright: #c5d5e5;

    --action: #00d4ff;
    --action-glow: rgba(0, 212, 255, 0.4);
    --subject: #bf5fff;
    --subject-glow: rgba(191, 95, 255, 0.4);
    --quality: #ffb800;
    --quality-glow: rgba(255, 184, 0, 0.4);
    --connect: #00ffa3;
    --connect-glow: rgba(0, 255, 163, 0.4);
    --respond: #ff5f87;
    --respond-glow: rgba(255, 95, 135, 0.4);
    --symbol: #8b9dc3;
    --symbol-glow: rgba(139, 157, 195, 0.4);
    --style: #ff9f43;
    --style-glow: rgba(255, 159, 67, 0.4);
    --mode: #a29bfe;
    --mode-glow: rgba(162, 155, 254, 0.4);

    --phonemic-consonant: #6ea8fe;
    --phonemic-vowel: #f59e6e;
    --phonemic-glow: rgba(124, 111, 239, 0.4);

    --accent: #00ffa3;
    --accent-glow: rgba(0, 255, 163, 0.3);
  }

  body {
    font-family: 'JetBrains Mono', monospace;
    background: var(--bg-deep);
    color: var(--text-bright);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* Scanline overlay */
  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.03) 2px,
      rgba(0, 0, 0, 0.03) 4px
    );
    pointer-events: none;
    z-index: 1000;
  }

  /* Status bar */
  #status-bar {
    padding: 8px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border);
    font-size: 11px;
    z-index: 10;
  }

  .status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--text-dim);
  }

  .status-dot.online {
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent-glow);
  }

  #mode-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    letter-spacing: 2px;
    padding: 4px 12px;
    border-radius: 3px;
    transition: all 0.3s ease;
  }

  #mode-label.semantic {
    color: var(--accent);
    background: rgba(0, 255, 163, 0.1);
    border: 1px solid rgba(0, 255, 163, 0.3);
  }

  #mode-label.phonemic {
    color: var(--phonemic-vowel);
    background: rgba(245, 158, 110, 0.1);
    border: 1px solid rgba(245, 158, 110, 0.3);
  }

  /* Output area */
  #output-area {
    flex: 1;
    padding: 16px 20px 8px;
    display: flex;
    flex-direction: column;
    min-height: 0;
    position: relative;
  }

  .section-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    letter-spacing: 3px;
    color: var(--text-dim);
    margin-bottom: 8px;
    text-transform: uppercase;
  }

  #text-output {
    flex: 1;
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 6px;
    padding: 16px;
    font-size: 18px;
    line-height: 1.7;
    overflow-y: auto;
    white-space: pre-wrap;
    word-wrap: break-word;
  }

  #text-output .cursor {
    display: inline-block;
    width: 2px;
    height: 1.1em;
    background: var(--accent);
    vertical-align: text-bottom;
    animation: blink 1s step-end infinite;
  }

  @keyframes blink { 50% { opacity: 0; } }

  /* Intent buffer */
  #intent-buffer {
    padding: 12px 20px;
    background: var(--bg-panel);
    border-top: 1px solid var(--border);
    min-height: 52px;
  }

  #intent-display {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
    min-height: 28px;
  }

  .intent-placeholder {
    color: var(--text-dim);
    font-size: 12px;
    font-style: italic;
  }

  .intent-token {
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: 600;
    letter-spacing: 0.5px;
    border: 1px solid;
    transition: all 0.15s ease;
  }

  .intent-token.action { color: var(--action); border-color: rgba(0, 212, 255, 0.4); background: rgba(0, 212, 255, 0.1); }
  .intent-token.subject { color: var(--subject); border-color: rgba(191, 95, 255, 0.4); background: rgba(191, 95, 255, 0.1); }
  .intent-token.quality { color: var(--quality); border-color: rgba(255, 184, 0, 0.4); background: rgba(255, 184, 0, 0.1); }
  .intent-token.connect { color: var(--connect); border-color: rgba(0, 255, 163, 0.4); background: rgba(0, 255, 163, 0.1); }
  .intent-token.respond { color: var(--respond); border-color: rgba(255, 95, 135, 0.4); background: rgba(255, 95, 135, 0.1); }
  .intent-token.symbol { color: var(--symbol); border-color: rgba(139, 157, 195, 0.4); background: rgba(139, 157, 195, 0.1); }
  .intent-token.style { color: var(--style); border-color: rgba(255, 159, 67, 0.4); background: rgba(255, 159, 67, 0.1); }
  .intent-token.literal { color: var(--phonemic-vowel); border-color: rgba(245, 158, 110, 0.4); background: rgba(245, 158, 110, 0.1); }
  .intent-token.phonemic { color: var(--phonemic-vowel); border-color: rgba(245, 158, 110, 0.6); background: rgba(245, 158, 110, 0.15); font-style: italic; }
  .intent-token.phonemic::before { content: '⟨'; margin-right: 2px; opacity: 0.6; }
  .intent-token.phonemic::after { content: '⟩'; margin-left: 2px; opacity: 0.6; }

  /* Phonemic buffer (shown when in phonemic mode) */
  .phonemic-buffer {
    display: inline-flex;
    align-items: center;
    gap: 4px;
    padding: 4px 10px;
    border-radius: 4px;
    font-size: 14px;
    color: var(--phonemic-vowel);
    border: 1px dashed rgba(245, 158, 110, 0.5);
    background: rgba(245, 158, 110, 0.05);
  }

  .phonemic-buffer::before {
    content: 'IPA:';
    font-size: 9px;
    color: var(--text-dim);
    margin-right: 4px;
  }

  /* Chord preview */
  #chord-preview {
    padding: 10px 20px;
    background: var(--bg-surface);
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 48px;
  }

  #preview-result {
    font-family: 'Orbitron', sans-serif;
    font-size: 16px;
    font-weight: 500;
    letter-spacing: 2px;
    transition: all 0.15s ease;
  }

  #preview-result.empty { color: var(--text-dim); }
  #preview-result.action { color: var(--action); text-shadow: 0 0 15px var(--action-glow); }
  #preview-result.subject { color: var(--subject); text-shadow: 0 0 15px var(--subject-glow); }
  #preview-result.quality { color: var(--quality); text-shadow: 0 0 15px var(--quality-glow); }
  #preview-result.connect { color: var(--connect); text-shadow: 0 0 15px var(--connect-glow); }
  #preview-result.respond { color: var(--respond); text-shadow: 0 0 15px var(--respond-glow); }
  #preview-result.symbol { color: var(--symbol); text-shadow: 0 0 15px var(--symbol-glow); }
  #preview-result.style { color: var(--style); text-shadow: 0 0 15px var(--style-glow); }
  #preview-result.mode { color: var(--mode); text-shadow: 0 0 15px var(--mode-glow); }
  #preview-result.control { color: var(--accent); text-shadow: 0 0 15px var(--accent-glow); }
  #preview-result.phonemic { color: var(--phonemic-vowel); text-shadow: 0 0 15px var(--phonemic-glow); }

  /* Predictions panel */
  #predictions-panel {
    padding: 8px 20px;
    background: var(--bg-panel);
    border-top: 1px solid var(--border);
    display: none;
  }

  #predictions-panel.visible {
    display: block;
  }

  .predictions-label {
    font-size: 9px;
    color: var(--text-dim);
    letter-spacing: 1px;
    margin-bottom: 6px;
  }

  .predictions-list {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .prediction-item {
    padding: 4px 10px;
    border-radius: 3px;
    font-size: 10px;
    background: var(--bg-surface);
    border: 1px solid var(--border);
    color: var(--text-mid);
    cursor: default;
    transition: all 0.15s ease;
  }

  .prediction-item:first-child {
    border-color: var(--accent);
    color: var(--accent);
  }

  .prediction-item .chord-hint {
    font-size: 8px;
    color: var(--text-dim);
    margin-left: 6px;
  }

  /* Keyboard area */
  #keyboard-area {
    padding: 16px 20px 20px;
    background: var(--bg-panel);
    border-top: 1px solid var(--border);
  }

  .keyboard-container {
    display: flex;
    justify-content: center;
    gap: 40px;
  }

  .hand {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
  }

  .hand-header {
    display: flex;
    align-items: center;
    gap: 12px;
    margin-bottom: 4px;
  }

  .hand-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 9px;
    letter-spacing: 2px;
    color: var(--text-dim);
    text-transform: uppercase;
  }

  .keys-row {
    display: flex;
    gap: 6px;
  }

  .key {
    width: 60px;
    height: 70px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    border: 1px solid var(--border);
    background: var(--bg-surface);
    transition: all 0.1s ease;
    position: relative;
    cursor: default;
  }

  .key::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    border-radius: 8px;
    opacity: 0;
    transition: opacity 0.15s ease;
  }

  .key .key-letter {
    font-size: 18px;
    font-weight: 600;
    color: var(--text-mid);
    transition: color 0.1s ease;
    z-index: 1;
  }

  .key .key-label {
    font-size: 9px;
    color: var(--text-dim);
    margin-top: 4px;
    text-align: center;
    max-width: 54px;
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
    z-index: 1;
    transition: all 0.15s ease;
  }

  /* Left hand - category keys */
  .key.left.pressed.action {
    background: rgba(0, 212, 255, 0.15);
    border-color: var(--action);
    box-shadow: 0 0 20px var(--action-glow), inset 0 0 20px rgba(0, 212, 255, 0.1);
  }
  .key.left.pressed.action .key-letter { color: var(--action); }
  .key.left.pressed.action .key-label { color: var(--action); }

  .key.left.pressed.subject {
    background: rgba(191, 95, 255, 0.15);
    border-color: var(--subject);
    box-shadow: 0 0 20px var(--subject-glow), inset 0 0 20px rgba(191, 95, 255, 0.1);
  }
  .key.left.pressed.subject .key-letter { color: var(--subject); }
  .key.left.pressed.subject .key-label { color: var(--subject); }

  .key.left.pressed.quality {
    background: rgba(255, 184, 0, 0.15);
    border-color: var(--quality);
    box-shadow: 0 0 20px var(--quality-glow), inset 0 0 20px rgba(255, 184, 0, 0.1);
  }
  .key.left.pressed.quality .key-letter { color: var(--quality); }
  .key.left.pressed.quality .key-label { color: var(--quality); }

  .key.left.pressed.connect {
    background: rgba(0, 255, 163, 0.15);
    border-color: var(--connect);
    box-shadow: 0 0 20px var(--connect-glow), inset 0 0 20px rgba(0, 255, 163, 0.1);
  }
  .key.left.pressed.connect .key-letter { color: var(--connect); }
  .key.left.pressed.connect .key-label { color: var(--connect); }

  .key.left.pressed.respond {
    background: rgba(255, 95, 135, 0.15);
    border-color: var(--respond);
    box-shadow: 0 0 20px var(--respond-glow), inset 0 0 20px rgba(255, 95, 135, 0.1);
  }
  .key.left.pressed.respond .key-letter { color: var(--respond); }
  .key.left.pressed.respond .key-label { color: var(--respond); }

  .key.left.pressed.symbol {
    background: rgba(139, 157, 195, 0.15);
    border-color: var(--symbol);
    box-shadow: 0 0 20px var(--symbol-glow), inset 0 0 20px rgba(139, 157, 195, 0.1);
  }
  .key.left.pressed.symbol .key-letter { color: var(--symbol); }
  .key.left.pressed.symbol .key-label { color: var(--symbol); }

  .key.left.pressed.style {
    background: rgba(255, 159, 67, 0.15);
    border-color: var(--style);
    box-shadow: 0 0 20px var(--style-glow), inset 0 0 20px rgba(255, 159, 67, 0.1);
  }
  .key.left.pressed.style .key-letter { color: var(--style); }
  .key.left.pressed.style .key-label { color: var(--style); }

  .key.left.pressed.mode {
    background: rgba(162, 155, 254, 0.15);
    border-color: var(--mode);
    box-shadow: 0 0 20px var(--mode-glow), inset 0 0 20px rgba(162, 155, 254, 0.1);
  }
  .key.left.pressed.mode .key-letter { color: var(--mode); }
  .key.left.pressed.mode .key-label { color: var(--mode); }

  /* Phonemic mode left hand */
  .key.left.pressed.phonemic-consonant {
    background: rgba(110, 168, 254, 0.15);
    border-color: var(--phonemic-consonant);
    box-shadow: 0 0 20px rgba(110, 168, 254, 0.4), inset 0 0 20px rgba(110, 168, 254, 0.1);
  }
  .key.left.pressed.phonemic-consonant .key-letter { color: var(--phonemic-consonant); }
  .key.left.pressed.phonemic-consonant .key-label { color: var(--phonemic-consonant); }

  /* Right hand */
  .key.right {
    height: 80px;
  }

  .key.right .key-label {
    font-size: 9px;
    min-height: 24px;
    opacity: 0;
    transform: translateY(4px);
    transition: all 0.15s ease;
  }

  .key.right.has-option .key-label {
    opacity: 1;
    transform: translateY(0);
  }

  .key.right.has-option {
    border-color: var(--border-glow);
  }
  .key.right.has-option::before { opacity: 1; }

  .key.right.has-option.action .key-label { color: var(--action); }
  .key.right.has-option.subject .key-label { color: var(--subject); }
  .key.right.has-option.quality .key-label { color: var(--quality); }
  .key.right.has-option.connect .key-label { color: var(--connect); }
  .key.right.has-option.respond .key-label { color: var(--respond); }
  .key.right.has-option.symbol .key-label { color: var(--symbol); }
  .key.right.has-option.style .key-label { color: var(--style); }
  .key.right.has-option.mode .key-label { color: var(--mode); }
  .key.right.has-option.phonemic .key-label { color: var(--phonemic-vowel); }

  .key.right.pressed {
    transform: translateY(2px);
  }

  .key.right.pressed.action {
    background: rgba(0, 212, 255, 0.2);
    border-color: var(--action);
    box-shadow: 0 0 25px var(--action-glow);
  }
  .key.right.pressed.action .key-letter { color: var(--action); }

  .key.right.pressed.subject {
    background: rgba(191, 95, 255, 0.2);
    border-color: var(--subject);
    box-shadow: 0 0 25px var(--subject-glow);
  }
  .key.right.pressed.subject .key-letter { color: var(--subject); }

  .key.right.pressed.quality {
    background: rgba(255, 184, 0, 0.2);
    border-color: var(--quality);
    box-shadow: 0 0 25px var(--quality-glow);
  }
  .key.right.pressed.quality .key-letter { color: var(--quality); }

  .key.right.pressed.connect {
    background: rgba(0, 255, 163, 0.2);
    border-color: var(--connect);
    box-shadow: 0 0 25px var(--connect-glow);
  }
  .key.right.pressed.connect .key-letter { color: var(--connect); }

  .key.right.pressed.respond {
    background: rgba(255, 95, 135, 0.2);
    border-color: var(--respond);
    box-shadow: 0 0 25px var(--respond-glow);
  }
  .key.right.pressed.respond .key-letter { color: var(--respond); }

  .key.right.pressed.symbol {
    background: rgba(139, 157, 195, 0.2);
    border-color: var(--symbol);
    box-shadow: 0 0 25px var(--symbol-glow);
  }
  .key.right.pressed.symbol .key-letter { color: var(--symbol); }

  .key.right.pressed.style {
    background: rgba(255, 159, 67, 0.2);
    border-color: var(--style);
    box-shadow: 0 0 25px var(--style-glow);
  }
  .key.right.pressed.style .key-letter { color: var(--style); }

  .key.right.pressed.mode {
    background: rgba(162, 155, 254, 0.2);
    border-color: var(--mode);
    box-shadow: 0 0 25px var(--mode-glow);
  }
  .key.right.pressed.mode .key-letter { color: var(--mode); }

  .key.right.pressed.phonemic {
    background: rgba(245, 158, 110, 0.2);
    border-color: var(--phonemic-vowel);
    box-shadow: 0 0 25px rgba(245, 158, 110, 0.4);
  }
  .key.right.pressed.phonemic .key-letter { color: var(--phonemic-vowel); }

  .key.right.pressed.control {
    background: rgba(0, 255, 163, 0.2);
    border-color: var(--accent);
    box-shadow: 0 0 25px var(--accent-glow);
  }
  .key.right.pressed.control .key-letter { color: var(--accent); }
  .key.right.pressed.control .key-label { color: var(--accent); }

  /* Fired animation */
  .key.fired {
    animation: keyFire 0.2s ease;
  }

  @keyframes keyFire {
    0% { transform: scale(1); }
    50% { transform: scale(0.95); }
    100% { transform: scale(1); }
  }

  /* Help bar */
  #help-bar {
    padding: 10px 20px;
    background: var(--bg-deep);
    border-top: 1px solid var(--border);
    display: flex;
    justify-content: center;
    gap: 24px;
    font-size: 10px;
    color: var(--text-dim);
  }

  #help-bar kbd {
    display: inline-block;
    padding: 2px 6px;
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 3px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: var(--text-mid);
    margin: 0 2px;
  }

  #help-bar a {
    color: var(--accent);
    text-decoration: none;
  }

  /* Invalid flash */
  .invalid-flash {
    animation: invalidShake 0.3s ease;
  }

  @keyframes invalidShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-4px); }
    75% { transform: translateX(4px); }
  }

  /* Scrollbar */
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: var(--bg-surface); }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
  ::-webkit-scrollbar-thumb:hover { background: var(--border-glow); }
</style>
</head>
<body>

<div id="status-bar">
  <div class="status-indicator">
    <span class="status-dot" id="status-dot"></span>
    <span id="server-status">Checking server...</span>
  </div>
  <span id="mode-label" class="semantic">SEMANTIC MODE</span>
  <span style="color: var(--text-dim);">Universal Intent Interface</span>
</div>

<div id="output-area">
  <div class="section-label">Output</div>
  <div id="text-output"><span class="cursor"></span></div>
</div>

<div id="intent-buffer">
  <div id="intent-display">
    <span class="intent-placeholder">Hold category key to see options...</span>
  </div>
</div>

<div id="predictions-panel">
  <div class="predictions-label">PREDICTED NEXT</div>
  <div class="predictions-list" id="predictions-list"></div>
</div>

<div id="chord-preview">
  <div id="preview-result" class="empty">READY</div>
</div>

<div id="keyboard-area">
  <div class="keyboard-container">
    <div class="hand" id="left-hand">
      <div class="hand-header">
        <div class="hand-title" id="left-hand-title">Category Select</div>
      </div>
      <div class="keys-row">
        <div class="key left" id="key-a" data-key="a" data-category="action">
          <span class="key-letter">A</span>
          <span class="key-label">ACTION</span>
        </div>
        <div class="key left" id="key-s" data-key="s" data-category="subject">
          <span class="key-letter">S</span>
          <span class="key-label">SUBJECT</span>
        </div>
        <div class="key left" id="key-d" data-key="d" data-category="quality">
          <span class="key-letter">D</span>
          <span class="key-label">QUALITY</span>
        </div>
        <div class="key left" id="key-f" data-key="f" data-category="connect">
          <span class="key-letter">F</span>
          <span class="key-label">CONNECT</span>
        </div>
        <div class="key left" id="key-c" data-key="c" data-category="respond">
          <span class="key-letter">C</span>
          <span class="key-label">RESPOND</span>
        </div>
      </div>
    </div>

    <div class="hand" id="right-hand">
      <div class="hand-header">
        <div class="hand-title" id="right-hand-title">Command Select</div>
      </div>
      <div class="keys-row">
        <div class="key right" id="key-m" data-key="m">
          <span class="key-letter">M</span>
          <span class="key-label">EXTEND</span>
        </div>
        <div class="key right" id="key-j" data-key="j">
          <span class="key-letter">J</span>
          <span class="key-label"></span>
        </div>
        <div class="key right" id="key-k" data-key="k">
          <span class="key-letter">K</span>
          <span class="key-label"></span>
        </div>
        <div class="key right" id="key-l" data-key="l">
          <span class="key-letter">L</span>
          <span class="key-label"></span>
        </div>
        <div class="key right" id="key-semicolon" data-key=";">
          <span class="key-letter">;</span>
          <span class="key-label"></span>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="help-bar">
  <span><kbd>Space</kbd> Expand</span>
  <span><kbd>C</kbd>+<kbd>M</kbd> Backspace</span>
  <span><kbd>C</kbd>+<kbd>;</kbd> Enter</span>
  <span><kbd>S</kbd>+<kbd>C</kbd>+<kbd>M</kbd> Toggle phonemic</span>
  <span><kbd>D</kbd>+<kbd>S</kbd>+<kbd>J</kbd> NAME</span>
  <a href="semantic-cheatsheet.html">Reference</a>
</div>

<script>
// ============================================================
// SEMANTIC VOCABULARY
// ============================================================

const SEMANTICS = {
  // ACTIONS (A)
  'A+J':       { symbol: 'MAKE', category: 'action' },
  'A+K':       { symbol: 'CHANGE', category: 'action' },
  'A+L':       { symbol: 'REMOVE', category: 'action' },
  'A+;':       { symbol: 'FIX', category: 'action' },
  'A+J+K':     { symbol: 'FIND', category: 'action' },
  'A+J+L':     { symbol: 'SHOW', category: 'action' },
  'A+J+;':     { symbol: 'TRY', category: 'action' },
  'A+K+L':     { symbol: 'USE', category: 'action' },
  'A+K+;':     { symbol: 'EXPLAIN', category: 'action' },
  'A+L+;':     { symbol: 'IMPROVE', category: 'action' },
  'A+J+K+L':   { symbol: 'COMPARE', category: 'action' },
  'A+J+K+;':   { symbol: 'ANALYZE', category: 'action' },
  'A+J+L+;':   { symbol: 'SUMMARIZE', category: 'action' },
  'A+K+L+;':   { symbol: 'EXPAND', category: 'action' },
  'A+J+K+L+;': { symbol: 'SIMPLIFY', category: 'action' },
  'A+M+J':     { symbol: 'ADD', category: 'action' },
  'A+M+K':     { symbol: 'KEEP', category: 'action' },
  'A+M+L':     { symbol: 'GIVE', category: 'action' },
  'A+M+;':     { symbol: 'TAKE', category: 'action' },
  'A+M+J+K':   { symbol: 'THINK', category: 'action' },
  'A+M+J+L':   { symbol: 'HELP', category: 'action' },
  'A+M+J+;':   { symbol: 'CHECK', category: 'action' },
  'A+M+K+L':   { symbol: 'LIST', category: 'action' },
  'A+M+K+;':   { symbol: 'COMBINE', category: 'action' },
  'A+M+L+;':   { symbol: 'SPLIT', category: 'action' },
  'A+M+J+K+L': { symbol: 'GENERATE', category: 'action' },
  'A+M+J+K+;': { symbol: 'TRANSLATE', category: 'action' },
  'A+M+J+L+;': { symbol: 'REWRITE', category: 'action' },
  'A+M+K+L+;': { symbol: 'FORMAT', category: 'action' },

  // SUBJECTS (S)
  'S+J':       { symbol: 'THIS', category: 'subject' },
  'S+K':       { symbol: 'THAT', category: 'subject' },
  'S+L':       { symbol: 'IT', category: 'subject' },
  'S+;':       { symbol: 'IDEA', category: 'subject' },
  'S+J+K':     { symbol: 'TEXT', category: 'subject' },
  'S+J+L':     { symbol: 'CODE', category: 'subject' },
  'S+J+;':     { symbol: 'QUESTION', category: 'subject' },
  'S+K+L':     { symbol: 'ANSWER', category: 'subject' },
  'S+K+;':     { symbol: 'PROBLEM', category: 'subject' },
  'S+L+;':     { symbol: 'SOLUTION', category: 'subject' },
  'S+J+K+L':   { symbol: 'EXAMPLE', category: 'subject' },
  'S+J+K+;':   { symbol: 'RESULT', category: 'subject' },
  'S+J+L+;':   { symbol: 'REASON', category: 'subject' },
  'S+K+L+;':   { symbol: 'WAY', category: 'subject' },
  'S+J+K+L+;': { symbol: 'POINT', category: 'subject' },
  'S+M+J':     { symbol: 'FILE', category: 'subject' },
  'S+M+K':     { symbol: 'FUNCTION', category: 'subject' },
  'S+M+L':     { symbol: 'DATA', category: 'subject' },
  'S+M+;':     { symbol: 'NAME', category: 'subject' },
  'S+M+J+K':   { symbol: 'LIST', category: 'subject' },
  'S+M+J+L':   { symbol: 'STEP', category: 'subject' },
  'S+M+J+;':   { symbol: 'PART', category: 'subject' },
  'S+M+K+L':   { symbol: 'OPTION', category: 'subject' },
  'S+M+K+;':   { symbol: 'ERROR', category: 'subject' },
  'S+M+L+;':   { symbol: 'OUTPUT', category: 'subject' },
  'S+M+J+K+L': { symbol: 'INPUT', category: 'subject' },
  'S+M+J+K+;': { symbol: 'CONTENT', category: 'subject' },
  'S+M+J+L+;': { symbol: 'CONTEXT', category: 'subject' },
  'S+M+K+L+;': { symbol: 'DETAIL', category: 'subject' },

  // QUALITY (D)
  'D+J':       { symbol: 'GOOD', category: 'quality' },
  'D+K':       { symbol: 'BAD', category: 'quality' },
  'D+L':       { symbol: 'MORE', category: 'quality' },
  'D+;':       { symbol: 'LESS', category: 'quality' },
  'D+J+K':     { symbol: 'SIMPLE', category: 'quality' },
  'D+J+L':     { symbol: 'COMPLEX', category: 'quality' },
  'D+J+;':     { symbol: 'NEW', category: 'quality' },
  'D+K+L':     { symbol: 'OLD', category: 'quality' },
  'D+K+;':     { symbol: 'SAME', category: 'quality' },
  'D+L+;':     { symbol: 'DIFFERENT', category: 'quality' },
  'D+J+K+L':   { symbol: 'GENERAL', category: 'quality' },
  'D+J+K+;':   { symbol: 'SPECIFIC', category: 'quality' },
  'D+J+L+;':   { symbol: 'MAIN', category: 'quality' },
  'D+K+L+;':   { symbol: 'OTHER', category: 'quality' },
  'D+J+K+L+;': { symbol: 'ALL', category: 'quality' },
  'D+M+J':     { symbol: 'FAST', category: 'quality' },
  'D+M+K':     { symbol: 'SLOW', category: 'quality' },
  'D+M+L':     { symbol: 'BIG', category: 'quality' },
  'D+M+;':     { symbol: 'SMALL', category: 'quality' },
  'D+M+J+K':   { symbol: 'SHORT', category: 'quality' },
  'D+M+J+L':   { symbol: 'LONG', category: 'quality' },
  'D+M+J+;':   { symbol: 'CLEAR', category: 'quality' },
  'D+M+K+L':   { symbol: 'BETTER', category: 'quality' },
  'D+M+K+;':   { symbol: 'WORSE', category: 'quality' },
  'D+M+L+;':   { symbol: 'CORRECT', category: 'quality' },
  'D+M+J+K+L': { symbol: 'WRONG', category: 'quality' },
  'D+M+J+K+;': { symbol: 'SIMILAR', category: 'quality' },
  'D+M+J+L+;': { symbol: 'EXACT', category: 'quality' },
  'D+M+K+L+;': { symbol: 'ENOUGH', category: 'quality' },

  // CONNECT (F)
  'F+J':       { symbol: 'AND', category: 'connect' },
  'F+K':       { symbol: 'OR', category: 'connect' },
  'F+L':       { symbol: 'BUT', category: 'connect' },
  'F+;':       { symbol: 'SO', category: 'connect' },
  'F+J+K':     { symbol: 'IF', category: 'connect' },
  'F+J+L':     { symbol: 'THEN', category: 'connect' },
  'F+J+;':     { symbol: 'BECAUSE', category: 'connect' },
  'F+K+L':     { symbol: 'WITH', category: 'connect' },
  'F+K+;':     { symbol: 'WITHOUT', category: 'connect' },
  'F+L+;':     { symbol: 'FOR', category: 'connect' },
  'F+J+K+L':   { symbol: 'TO', category: 'connect' },
  'F+J+K+;':   { symbol: 'FROM', category: 'connect' },
  'F+J+L+;':   { symbol: 'LIKE', category: 'connect' },
  'F+K+L+;':   { symbol: 'AS', category: 'connect' },
  'F+J+K+L+;': { symbol: 'ABOUT', category: 'connect' },
  'F+M+J':     { symbol: 'ALSO', category: 'connect' },
  'F+M+K':     { symbol: 'HOWEVER', category: 'connect' },
  'F+M+L':     { symbol: 'INSTEAD', category: 'connect' },
  'F+M+;':     { symbol: 'RATHER', category: 'connect' },
  'F+M+J+K':   { symbol: 'BEFORE', category: 'connect' },
  'F+M+J+L':   { symbol: 'AFTER', category: 'connect' },
  'F+M+J+;':   { symbol: 'WHILE', category: 'connect' },
  'F+M+K+L':   { symbol: 'WHEN', category: 'connect' },
  'F+M+K+;':   { symbol: 'WHERE', category: 'connect' },
  'F+M+L+;':   { symbol: 'ALTHOUGH', category: 'connect' },
  'F+M+J+K+L': { symbol: 'UNLESS', category: 'connect' },
  'F+M+J+K+;': { symbol: 'UNTIL', category: 'connect' },
  'F+M+J+L+;': { symbol: 'SINCE', category: 'connect' },
  'F+M+K+L+;': { symbol: 'WHETHER', category: 'connect' },

  // RESPOND (C)
  'C+J':       { symbol: 'YES', category: 'respond' },
  'C+K':       { symbol: 'NO', category: 'respond' },
  'C+L':       { symbol: 'MAYBE', category: 'respond' },
  'C+;':       { symbol: 'OK', category: 'respond' },
  'C+J+K':     { symbol: 'THANKS', category: 'respond' },
  'C+J+L':     { symbol: 'PLEASE', category: 'respond' },
  'C+J+;':     { symbol: 'SORRY', category: 'respond' },
  'C+K+L':     { symbol: 'WAIT', category: 'respond' },
  'C+K+;':     { symbol: 'DONE', category: 'respond' },
  'C+L+;':     { symbol: 'AGAIN', category: 'respond' },
  'C+J+K+L':   { symbol: 'WHAT', category: 'respond' },
  'C+J+K+;':   { symbol: 'WHY', category: 'respond' },
  'C+J+L+;':   { symbol: 'HOW', category: 'respond' },
  'C+K+L+;':   { symbol: 'WHICH', category: 'respond' },
  'C+J+K+L+;': { symbol: 'WHO', category: 'respond' },
  'C+M+J':     { symbol: 'CONTINUE', category: 'respond' },
  'C+M+K':     { symbol: 'STOP', category: 'respond' },
  'C+M+L':     { symbol: 'UNDO', category: 'respond' },
  'C+M+;':     { symbol: 'SKIP', category: 'respond' },
  'C+M+J+K':   { symbol: 'FOCUS', category: 'respond' },
  'C+M+J+L':   { symbol: 'IGNORE', category: 'respond' },
  'C+M+J+;':   { symbol: 'REMEMBER', category: 'respond' },
  'C+M+K+L':   { symbol: 'FORGET', category: 'respond' },
  'C+M+K+;':   { symbol: 'CONFIRM', category: 'respond' },
  'C+M+L+;':   { symbol: 'NEVERMIND', category: 'respond' },
  'C+M+J+K+L': { symbol: 'PERFECT', category: 'respond' },
  'C+M+J+K+;': { symbol: 'ALMOST', category: 'respond' },
  'C+M+J+L+;': { symbol: 'NOT_QUITE', category: 'respond' },
  'C+M+K+L+;': { symbol: 'EXACTLY', category: 'respond' },

  // SYMBOLS (A+F)
  'A+F+J':       { symbol: '1', category: 'symbol' },
  'A+F+K':       { symbol: '2', category: 'symbol' },
  'A+F+L':       { symbol: '3', category: 'symbol' },
  'A+F+;':       { symbol: '4', category: 'symbol' },
  'A+F+J+K':     { symbol: '5', category: 'symbol' },
  'A+F+J+L':     { symbol: '6', category: 'symbol' },
  'A+F+J+;':     { symbol: '7', category: 'symbol' },
  'A+F+K+L':     { symbol: '8', category: 'symbol' },
  'A+F+K+;':     { symbol: '9', category: 'symbol' },
  'A+F+L+;':     { symbol: '0', category: 'symbol' },
  'A+F+J+K+L':   { symbol: '.', category: 'symbol' },
  'A+F+J+K+;':   { symbol: ',', category: 'symbol' },
  'A+F+J+L+;':   { symbol: '?', category: 'symbol' },
  'A+F+K+L+;':   { symbol: '!', category: 'symbol' },
  'A+F+J+K+L+;': { symbol: ':', category: 'symbol' },
  'A+F+M+J':     { symbol: '-', category: 'symbol' },
  'A+F+M+K':     { symbol: '_', category: 'symbol' },
  'A+F+M+L':     { symbol: '/', category: 'symbol' },
  'A+F+M+;':     { symbol: '@', category: 'symbol' },
  'A+F+M+J+K':   { symbol: '#', category: 'symbol' },
  'A+F+M+J+L':   { symbol: '$', category: 'symbol' },
  'A+F+M+J+;':   { symbol: '%', category: 'symbol' },
  'A+F+M+K+L':   { symbol: '&', category: 'symbol' },
  'A+F+M+K+;':   { symbol: '*', category: 'symbol' },
  'A+F+M+L+;':   { symbol: '+', category: 'symbol' },
  'A+F+M+J+K+L': { symbol: '=', category: 'symbol' },
  'A+F+M+J+K+;': { symbol: '(', category: 'symbol' },
  'A+F+M+J+L+;': { symbol: ')', category: 'symbol' },
  'A+F+M+K+L+;': { symbol: '"', category: 'symbol' },

  // DAILY CONVERSATION (A+S = common verbs)
  'A+S+J':       { symbol: 'GREET', category: 'action' },
  'A+S+K':       { symbol: 'ASK', category: 'action' },
  'A+S+L':       { symbol: 'TELL', category: 'action' },
  'A+S+;':       { symbol: 'WANT', category: 'action' },
  'A+S+J+K':     { symbol: 'NEED', category: 'action' },
  'A+S+J+L':     { symbol: 'KNOW', category: 'action' },
  'A+S+J+;':     { symbol: 'MEET', category: 'action' },
  'A+S+K+L':     { symbol: 'CALL', category: 'action' },
  'A+S+K+;':     { symbol: 'SEND', category: 'action' },
  'A+S+L+;':     { symbol: 'GET', category: 'action' },
  'A+S+J+K+L':   { symbol: 'START', category: 'action' },
  'A+S+J+K+;':   { symbol: 'FINISH', category: 'action' },
  'A+S+J+L+;':   { symbol: 'SCHEDULE', category: 'action' },
  'A+S+K+L+;':   { symbol: 'CANCEL', category: 'action' },

  // PEOPLE & PLACES (D+S = noun markers)
  'D+S+J':       { symbol: 'NAME', category: 'subject' },   // Critical: marks next literal as proper noun
  'D+S+K':       { symbol: 'PERSON', category: 'subject' },
  'D+S+L':       { symbol: 'PLACE', category: 'subject' },
  'D+S+;':       { symbol: 'THING', category: 'subject' },
  'D+S+J+K':     { symbol: 'TEAM', category: 'subject' },
  'D+S+J+L':     { symbol: 'COMPANY', category: 'subject' },
  'D+S+K+L':     { symbol: 'PROJECT', category: 'subject' },
  'D+S+K+;':     { symbol: 'MEETING', category: 'subject' },

  // TIME (A+D = temporal)
  'A+D+J':       { symbol: 'TODAY', category: 'subject' },
  'A+D+K':       { symbol: 'TOMORROW', category: 'subject' },
  'A+D+L':       { symbol: 'NOW', category: 'subject' },
  'A+D+;':       { symbol: 'LATER', category: 'subject' },
  'A+D+J+K':     { symbol: 'SOON', category: 'subject' },
  'A+D+J+L':     { symbol: 'YESTERDAY', category: 'subject' },
  'A+D+K+L':     { symbol: 'TIME', category: 'subject' },
  'A+D+K+;':     { symbol: 'DATE', category: 'subject' },

  // FEELINGS (F+D = states)
  'F+D+J':       { symbol: 'HAPPY', category: 'quality' },
  'F+D+K':       { symbol: 'BUSY', category: 'quality' },
  'F+D+L':       { symbol: 'READY', category: 'quality' },
  'F+D+;':       { symbol: 'SURE', category: 'quality' },
  'F+D+J+K':     { symbol: 'AVAILABLE', category: 'quality' },
  'F+D+J+L':     { symbol: 'INTERESTED', category: 'quality' },
  'F+D+K+L':     { symbol: 'URGENT', category: 'quality' },
  'F+D+K+;':     { symbol: 'IMPORTANT', category: 'quality' },

  // STYLE MODIFIERS (D+C)
  'D+C+J':       { symbol: 'FORMAL', category: 'style' },
  'D+C+K':       { symbol: 'CASUAL', category: 'style' },
  'D+C+L':       { symbol: 'POLITE', category: 'style' },
  'D+C+;':       { symbol: 'DIRECT', category: 'style' },
  'D+C+J+K':     { symbol: 'TECHNICAL', category: 'style' },
  'D+C+J+L':     { symbol: 'FRIENDLY', category: 'style' },
  'D+C+J+;':     { symbol: 'PROFESSIONAL', category: 'style' },
  'D+C+K+L':     { symbol: 'BRIEF', category: 'style' },
  'D+C+K+;':     { symbol: 'DETAILED', category: 'style' },
  'D+C+L+;':     { symbol: 'AS_QUESTION', category: 'style' },
  'D+C+J+K+L':   { symbol: 'AS_COMMAND', category: 'style' },
  'D+C+J+K+;':   { symbol: 'AS_REQUEST', category: 'style' },
  'D+C+M+J':     { symbol: 'REPROMPT', category: 'style' },
};

// ============================================================
// PHONEMIC VOCABULARY (from index.html)
// ============================================================

const CONSONANTS = {
  0:  null,   1:  'f',    2:  'p',    3:  'st',   4:  't',
  5:  's',    6:  'θ',    7:  'ð',    8:  'r',
  9:  'ʃ',    10: 'nd',   11: 'tr',   12: 'k',
  13: 'h',    14: 'pr',   15: 'str',  16: 'b',
  17: 'v',    18: 'm',    19: 'w',    20: 'd',
  21: 'z',    22: 'n',    23: 'dʒ',   24: 'l',
  25: 'ʒ',    26: 'nt',   27: 'tʃ',   28: 'g',
  29: 'sp',   30: 'ŋ',    31: 'j',
};

const VOWELS = {
  0:  null,
  1:  'i',    2:  'o',    3:  'u',    4:  'e',
  5:  'ə',    6:  'at',   7:  'in',   8:  'a',
  9:  'an',   10: 'on',   11: 'it',   12: 'er',
  13: 'or',   14: 'al',   15: 'ing',
  16: 'ot',   17: 'ī',    18: 'ō',    19: 'ū',
  20: 'ē',    21: 'et',   22: 'ut',   23: 'en',
  24: 'ā',    25: 'un',   26: 'ad',   27: 'is',
  28: 'il',   29: 'aw',   30: 'oi',   31: 'ow',
};

// Phonemic key labels for display
const CONSONANT_LABELS = {
  'a': 'manner', 's': 'manner', 'd': 'place', 'f': 'place', 'c': 'voice'
};

const VOWEL_LABELS = {
  'm': 'mod', 'j': 'height', 'k': 'height', 'l': 'back', ';': 'back'
};

// ============================================================
// PREDICTIVE NEXT-TOKEN
// ============================================================

// Transition probabilities: what tokens commonly follow what
const TOKEN_TRANSITIONS = {
  // After actions, expect subjects or qualities
  'MAKE': ['THIS', 'IT', 'SIMPLE', 'NEW', 'BETTER', 'MORE'],
  'CHANGE': ['THIS', 'IT', 'TO', 'THAT', 'NAME'],
  'FIX': ['THIS', 'IT', 'ERROR', 'PROBLEM'],
  'FIND': ['THIS', 'IT', 'ALL', 'ERROR', 'FILE', 'TIME'],
  'SHOW': ['THIS', 'EXAMPLE', 'MORE', 'ALL'],
  'EXPLAIN': ['THIS', 'HOW', 'WHY', 'MORE', 'SIMPLE'],
  'ADD': ['THIS', 'MORE', 'NEW', 'TO', 'AND'],
  'HELP': ['WITH', 'THIS', 'PLEASE', 'NAME'],
  'CHECK': ['THIS', 'IT', 'IF', 'ERROR', 'TIME'],

  // Daily conversation actions
  'GREET': ['NAME', 'POLITE', 'FORMAL', 'CASUAL'],
  'ASK': ['NAME', 'ABOUT', 'IF', 'QUESTION', 'TIME'],
  'TELL': ['NAME', 'ABOUT', 'THIS', 'THAT'],
  'WANT': ['TO', 'THIS', 'MEET', 'KNOW', 'NAME'],
  'NEED': ['TO', 'THIS', 'HELP', 'MORE', 'TIME'],
  'KNOW': ['IF', 'ABOUT', 'THIS', 'THAT', 'WHEN'],
  'MEET': ['NAME', 'TODAY', 'TOMORROW', 'LATER', 'SOON'],
  'CALL': ['NAME', 'TODAY', 'LATER', 'BACK'],
  'SEND': ['THIS', 'TO', 'NAME', 'EMAIL'],
  'GET': ['THIS', 'BACK', 'TO', 'FROM'],
  'START': ['THIS', 'NOW', 'TODAY', 'WITH'],
  'FINISH': ['THIS', 'TODAY', 'BY', 'BEFORE'],
  'SCHEDULE': ['MEETING', 'CALL', 'WITH', 'NAME', 'FOR'],
  'CANCEL': ['THIS', 'MEETING', 'THAT'],

  // After NAME, expect phonemic input or more context
  'NAME': ['AND', 'ABOUT', 'TODAY', 'TOMORROW'],

  // After subjects, expect qualities or connectors
  'THIS': ['AND', 'TO', 'WITH', 'BUT', 'OR', 'SIMPLE', 'BETTER'],
  'IT': ['TO', 'WITH', 'AND', 'BUT', 'SIMPLE', 'BETTER'],
  'CODE': ['AND', 'TO', 'WITH', 'SIMPLE', 'BETTER', 'ERROR'],
  'TEXT': ['AND', 'TO', 'SHORT', 'CLEAR', 'MORE'],
  'IDEA': ['AND', 'BUT', 'ABOUT', 'INTERESTING'],
  'ERROR': ['AND', 'FIX', 'SHOW', 'WHY'],
  'PERSON': ['NAME', 'AND', 'WHO'],
  'PLACE': ['NAME', 'AND', 'WHERE'],
  'MEETING': ['WITH', 'NAME', 'TODAY', 'TOMORROW', 'ABOUT'],
  'PROJECT': ['AND', 'ABOUT', 'THIS', 'NAME'],

  // Time tokens
  'TODAY': ['LATER', 'NOW', 'AND', 'PLEASE'],
  'TOMORROW': ['AND', 'PLEASE', 'IF'],
  'NOW': ['AND', 'PLEASE', 'IF'],
  'LATER': ['TODAY', 'AND', 'PLEASE'],
  'SOON': ['AND', 'PLEASE', 'THANKS'],

  // After qualities, expect connectors or subjects
  'GOOD': ['AND', 'BUT', 'IDEA', 'THANKS'],
  'BAD': ['AND', 'BUT', 'IDEA', 'FIX'],
  'MORE': ['DETAIL', 'SIMPLE', 'CLEAR', 'AND', 'TIME'],
  'SIMPLE': ['AND', 'CLEAR', 'BUT', 'MORE'],
  'BETTER': ['AND', 'BUT', 'MORE', 'WAY'],
  'BUSY': ['NOW', 'TODAY', 'BUT', 'LATER'],
  'READY': ['TO', 'FOR', 'NOW', 'AND'],
  'INTERESTED': ['IN', 'ABOUT', 'AND'],
  'AVAILABLE': ['TODAY', 'TOMORROW', 'NOW', 'LATER'],

  // After connectors, expect subjects or actions
  'AND': ['MAKE', 'ADD', 'SHOW', 'THIS', 'MORE', 'ALSO', 'MEET'],
  'BUT': ['MORE', 'SIMPLE', 'HOW', 'WHY', 'DIFFERENT', 'BUSY'],
  'TO': ['THIS', 'THAT', 'IT', 'MAKE', 'MEET', 'NAME'],
  'WITH': ['THIS', 'MORE', 'EXAMPLE', 'NAME', 'TEAM'],
  'IF': ['THIS', 'IT', 'AVAILABLE', 'POSSIBLE', 'OK'],
  'ABOUT': ['THIS', 'THAT', 'PROJECT', 'MEETING', 'IDEA'],

  // After responses, expect actions or end
  'YES': ['AND', 'BUT', 'THANKS', 'PLEASE', 'PERFECT'],
  'NO': ['BUT', 'BECAUSE', 'INSTEAD', 'WAIT', 'SORRY'],
  'THANKS': ['AND', 'BUT', 'PLEASE', 'FOR'],
  'PLEASE': ['MAKE', 'SHOW', 'HELP', 'FIX', 'ADD', 'CALL', 'SEND'],
  'OK': ['AND', 'THANKS', 'PLEASE', 'SOUNDS'],

  // Style modifiers
  'POLITE': ['PROFESSIONAL', 'FRIENDLY', 'FORMAL', 'GREET', 'ASK'],
  'FORMAL': ['PROFESSIONAL', 'BRIEF', 'GREET', 'REPROMPT'],
  'CASUAL': ['FRIENDLY', 'BRIEF', 'GREET', 'REPROMPT'],
  'PROFESSIONAL': ['GREET', 'ASK', 'REPROMPT'],
};

// Default predictions when no specific match
const DEFAULT_PREDICTIONS = ['THIS', 'AND', 'NAME', 'PLEASE', 'TODAY', 'ABOUT'];

function getPredictions(buffer) {
  if (buffer.length === 0) {
    // Show common starters for daily use
    return ['GREET', 'PLEASE', 'WANT', 'NEED', 'ASK', 'POLITE'];
  }

  const lastToken = buffer[buffer.length - 1];

  // Handle phonemic tokens (raw IPA)
  if (lastToken.isRawIPA) {
    return ['AND', 'ABOUT', 'TODAY', 'TOMORROW', 'PLEASE', 'THANKS'];
  }

  const predictions = TOKEN_TRANSITIONS[lastToken.symbol] || DEFAULT_PREDICTIONS;

  // Filter out tokens already in buffer (by symbol, not phonemic)
  const usedSymbols = new Set(buffer.filter(t => !t.isRawIPA).map(t => t.symbol));
  return predictions.filter(p => !usedSymbols.has(p)).slice(0, 6);
}

// ============================================================
// CHORD ENGINE UTILITIES
// ============================================================

const LEFT_KEY_ORDER = ['A', 'S', 'D', 'F', 'C'];
const RIGHT_KEY_ORDER = ['M', 'J', 'K', 'L', ';'];

function sortByOrder(keys, order) {
  return keys.slice().sort((a, b) => order.indexOf(a) - order.indexOf(b));
}

function normalizeChordKey(leftKeys, rightKeys) {
  const sortedLeft = sortByOrder(leftKeys, LEFT_KEY_ORDER);
  const sortedRight = sortByOrder(rightKeys, RIGHT_KEY_ORDER);
  return sortedLeft.join('+') + '+' + sortedRight.join('+');
}

// Build normalized lookup table
const SEMANTICS_LOOKUP = {};
for (const [chord, data] of Object.entries(SEMANTICS)) {
  const parts = chord.split('+');
  const leftParts = parts.filter(p => LEFT_KEY_ORDER.includes(p));
  const rightParts = parts.filter(p => RIGHT_KEY_ORDER.includes(p));
  const normalized = normalizeChordKey(leftParts, rightParts);
  SEMANTICS_LOOKUP[normalized] = data;
}

function getOptionsForLeftKeys(leftKeys) {
  const options = {};
  const leftPrefix = sortByOrder(leftKeys, LEFT_KEY_ORDER).join('+');

  for (const [chord, data] of Object.entries(SEMANTICS)) {
    const parts = chord.split('+');
    const chordLeft = sortByOrder(parts.filter(p => LEFT_KEY_ORDER.includes(p)), LEFT_KEY_ORDER).join('+');
    const chordRight = parts.filter(p => RIGHT_KEY_ORDER.includes(p));

    if (chordLeft === leftPrefix) {
      const rightKey = sortByOrder(chordRight, RIGHT_KEY_ORDER).join('+');
      options[rightKey] = data;
    }
  }

  return options;
}

// ============================================================
// CONFIG & STATE
// ============================================================

const API_BASE = 'http://localhost:8000';
let serverOnline = false;

const LEFT_KEYS = { 'c': 4, 'f': 3, 'd': 2, 's': 1, 'a': 0 };
const RIGHT_KEYS = { 'm': 4, 'j': 3, 'k': 2, 'l': 1, ';': 0 };
const LEFT_KEY_CATEGORIES = { 'a': 'action', 's': 'subject', 'd': 'quality', 'f': 'connect', 'c': 'respond' };

const heldKeys = new Set();
const chordBuffer = new Set();
let chordActive = false;
let completedLines = [];
let semanticBuffer = [];
let phonemicBuffer = [];
let expanding = false;
let lastExpansionTokens = [];
let lastExpansionResult = '';

// MODE: 'semantic' or 'phonemic'
let currentMode = 'semantic';
let phonemicStartIndex = -1;  // Where phonemic input started in semantic buffer

// DOM elements
const textOutput = document.getElementById('text-output');
const intentDisplay = document.getElementById('intent-display');
const previewResult = document.getElementById('preview-result');
const predictionsPanel = document.getElementById('predictions-panel');
const predictionsList = document.getElementById('predictions-list');
const modeLabel = document.getElementById('mode-label');
const leftHandTitle = document.getElementById('left-hand-title');
const rightHandTitle = document.getElementById('right-hand-title');

// ============================================================
// MODE SWITCHING
// ============================================================

function setMode(mode) {
  currentMode = mode;
  modeLabel.textContent = mode === 'semantic' ? 'SEMANTIC MODE' : 'PHONEMIC MODE';
  modeLabel.className = mode;

  // Update hand labels
  if (mode === 'semantic') {
    leftHandTitle.textContent = 'Category Select';
    rightHandTitle.textContent = 'Command Select';
  } else {
    leftHandTitle.textContent = 'Consonant';
    rightHandTitle.textContent = 'Vowel';
  }

  // Update key labels
  updateKeyLabelsForMode();
  updateDisplay();
  updateKeyVisuals();
  updatePreview();
}

function toggleMode() {
  if (currentMode === 'semantic') {
    // Entering phonemic mode
    phonemicStartIndex = semanticBuffer.length;
    phonemicBuffer = [];
    setMode('phonemic');
  } else {
    // Exiting phonemic mode - lock IPA in place
    if (phonemicBuffer.length > 0) {
      const ipa = phonemicBuffer.join('');
      // Add as phonemic token (raw IPA, will be converted later)
      semanticBuffer.push({ symbol: ipa, category: 'phonemic', isRawIPA: true });
      phonemicBuffer = [];
    }
    phonemicStartIndex = -1;
    setMode('semantic');
  }
}

function updateKeyLabelsForMode() {
  // Update left hand labels
  document.querySelectorAll('.key.left').forEach(keyEl => {
    const key = keyEl.dataset.key;
    const labelEl = keyEl.querySelector('.key-label');

    if (currentMode === 'semantic') {
      const cat = keyEl.dataset.category;
      labelEl.textContent = cat ? cat.toUpperCase() : '';
    } else {
      labelEl.textContent = CONSONANT_LABELS[key] || '';
    }
  });

  // Update right hand labels (will be updated dynamically)
  document.querySelectorAll('.key.right').forEach(keyEl => {
    const key = keyEl.dataset.key;
    const labelEl = keyEl.querySelector('.key-label');

    if (currentMode === 'phonemic') {
      labelEl.textContent = VOWEL_LABELS[key] || '';
      keyEl.classList.add('has-option', 'phonemic');
    }
  });
}

// ============================================================
// CHORD ENGINE
// ============================================================

function isChordKey(key) { return key in LEFT_KEYS || key in RIGHT_KEYS; }

function getLeftCode() {
  let code = 0;
  for (const key of chordBuffer) {
    if (key in LEFT_KEYS) code |= (1 << LEFT_KEYS[key]);
  }
  return code;
}

function getRightCode() {
  let code = 0;
  for (const key of chordBuffer) {
    if (key in RIGHT_KEYS) code |= (1 << RIGHT_KEYS[key]);
  }
  return code;
}

function codeToKeys(code, isLeft) {
  const keys = [];
  const keyMap = isLeft ? ['A', 'S', 'D', 'F', 'C'] : [';', 'L', 'K', 'J', 'M'];
  for (let i = 0; i < 5; i++) {
    if (code & (1 << i)) keys.push(keyMap[i]);
  }
  return keys;
}

function getChordKey(leftCode, rightCode) {
  const leftKeys = codeToKeys(leftCode, true);
  const rightKeys = codeToKeys(rightCode, false);
  if (leftKeys.length === 0 || rightKeys.length === 0) return null;
  return normalizeChordKey(leftKeys, rightKeys);
}

function lookupSemantic(chordKey) {
  return SEMANTICS_LOOKUP[chordKey];
}

function getHeldLeftKeys() {
  const keys = [];
  for (const key of chordBuffer) {
    if (key in LEFT_KEYS) keys.push(key.toUpperCase());
  }
  return sortByOrder(keys, LEFT_KEY_ORDER);
}

function getHeldRightKeys() {
  const keys = [];
  for (const key of chordBuffer) {
    if (key in RIGHT_KEYS) keys.push(key === ';' ? ';' : key.toUpperCase());
  }
  return sortByOrder(keys, RIGHT_KEY_ORDER);
}

function getCurrentCategory() {
  const leftHeld = getHeldLeftKeys();

  // Check for combo categories
  if (leftHeld.includes('A') && leftHeld.includes('F')) return 'symbol';
  if (leftHeld.includes('D') && leftHeld.includes('C')) return 'style';
  if (leftHeld.includes('S') && leftHeld.includes('C')) return 'mode';

  // Single category
  for (const key of chordBuffer) {
    if (key in LEFT_KEY_CATEGORIES) {
      return LEFT_KEY_CATEGORIES[key];
    }
  }
  return null;
}

// ============================================================
// DISPLAY UPDATES
// ============================================================

function escapeHtml(text) {
  return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function updateDisplay() {
  let html = '';
  if (completedLines.length > 0) {
    html += completedLines.map(l => escapeHtml(l)).join('\n');
  }
  html += '<span class="cursor"></span>';
  textOutput.innerHTML = html;
  textOutput.scrollTop = textOutput.scrollHeight;

  // Update intent buffer
  if (semanticBuffer.length > 0 || phonemicBuffer.length > 0 || currentMode === 'phonemic') {
    let bufferHtml = '';

    // Show semantic tokens (including locked phonemic tokens)
    bufferHtml += semanticBuffer.map(token => {
      if (token.isRawIPA) {
        // Show phonemic tokens with special styling
        return `<span class="intent-token phonemic">${escapeHtml(token.symbol)}</span>`;
      }
      return `<span class="intent-token ${token.category}">${escapeHtml(token.symbol)}</span>`;
    }).join('');

    // Show active phonemic buffer if currently typing IPA
    if (currentMode === 'phonemic') {
      const ipaContent = phonemicBuffer.length > 0 ? phonemicBuffer.join('') : '...';
      bufferHtml += `<span class="phonemic-buffer">${escapeHtml(ipaContent)}</span>`;
    }

    intentDisplay.innerHTML = bufferHtml || '<span class="intent-placeholder">Chord consonants + vowels...</span>';
  } else {
    intentDisplay.innerHTML = '<span class="intent-placeholder">Hold category key to see options...</span>';
  }

  // Update predictions
  updatePredictions();
}

function updatePredictions() {
  if (currentMode !== 'semantic' || expanding) {
    predictionsPanel.classList.remove('visible');
    return;
  }

  const predictions = getPredictions(semanticBuffer);

  if (predictions.length > 0 && !chordActive) {
    predictionsPanel.classList.add('visible');
    predictionsList.innerHTML = predictions.map(p => {
      // Find the chord for this prediction
      const chord = Object.entries(SEMANTICS).find(([k, v]) => v.symbol === p);
      const chordHint = chord ? chord[0].replace(/\+/g, '+') : '';
      return `<span class="prediction-item">${p}<span class="chord-hint">${chordHint}</span></span>`;
    }).join('');
  } else {
    predictionsPanel.classList.remove('visible');
  }
}

function updateKeyVisuals() {
  const leftHeld = getHeldLeftKeys();
  const rightHeld = getHeldRightKeys();
  const category = getCurrentCategory();

  const isSymbolMode = leftHeld.includes('A') && leftHeld.includes('F');
  const isStyleMode = leftHeld.includes('D') && leftHeld.includes('C');
  const isModeToggle = leftHeld.includes('S') && leftHeld.includes('C');

  // Update left hand keys
  document.querySelectorAll('.key.left').forEach(keyEl => {
    const key = keyEl.dataset.key;
    const isPressed = heldKeys.has(key);
    const keyCategory = keyEl.dataset.category;

    keyEl.classList.remove('pressed', 'action', 'subject', 'quality', 'connect', 'respond', 'symbol', 'style', 'mode', 'phonemic-consonant');

    if (isPressed) {
      if (currentMode === 'phonemic') {
        keyEl.classList.add('pressed', 'phonemic-consonant');
      } else if (isSymbolMode) {
        keyEl.classList.add('pressed', 'symbol');
      } else if (isStyleMode) {
        keyEl.classList.add('pressed', 'style');
      } else if (isModeToggle) {
        keyEl.classList.add('pressed', 'mode');
      } else {
        keyEl.classList.add('pressed', keyCategory);
      }
    }
  });

  // Update right hand keys
  if (currentMode === 'phonemic') {
    updateRightKeysPhonemic();
  } else {
    updateRightKeysSemantic(leftHeld, rightHeld, category);
  }
}

function updateRightKeysSemantic(leftHeld, rightHeld, category) {
  const options = leftHeld.length > 0 ? getOptionsForLeftKeys(leftHeld) : {};

  document.querySelectorAll('.key.right').forEach(keyEl => {
    const key = keyEl.dataset.key;
    const keyUpper = key === ';' ? ';' : key.toUpperCase();
    const isPressed = heldKeys.has(key);
    const labelEl = keyEl.querySelector('.key-label');

    keyEl.classList.remove('pressed', 'has-option', 'action', 'subject', 'quality', 'connect', 'respond', 'symbol', 'style', 'mode', 'phonemic', 'control');

    // Check for backspace control chord
    if (leftHeld.includes('C') && leftHeld.length === 1 && key === 'm') {
      keyEl.classList.add('has-option', 'control');
      labelEl.textContent = 'BACKSPACE';
      if (isPressed) keyEl.classList.add('pressed', 'control');
      return;
    }

    // Check for mode toggle chord (S+C+M)
    if (leftHeld.includes('S') && leftHeld.includes('C') && key === 'm') {
      keyEl.classList.add('has-option', 'mode');
      labelEl.textContent = 'PHONEMIC';
      if (isPressed) keyEl.classList.add('pressed', 'mode');
      return;
    }

    // Check for Enter chord (C+;)
    if (leftHeld.includes('C') && leftHeld.length === 1 && key === ';') {
      keyEl.classList.add('has-option', 'control');
      labelEl.textContent = 'ENTER';
      if (isPressed) keyEl.classList.add('pressed', 'control');
      return;
    }

    // Find what this key would produce
    const currentRight = [...rightHeld];
    if (!currentRight.includes(keyUpper)) currentRight.push(keyUpper);
    const rightKey = sortByOrder(currentRight, RIGHT_KEY_ORDER).join('+');

    if (options[rightKey]) {
      const opt = options[rightKey];
      keyEl.classList.add('has-option', opt.category);
      labelEl.textContent = opt.symbol;
      if (isPressed) keyEl.classList.add('pressed', opt.category);
    } else if (key === 'm' && leftHeld.length > 0) {
      keyEl.classList.add('has-option');
      labelEl.textContent = '+MORE';
      labelEl.style.color = 'var(--text-mid)';
      if (isPressed) {
        keyEl.classList.add('pressed');
        keyEl.style.borderColor = 'var(--border-glow)';
      }
    } else {
      labelEl.textContent = '';
      if (isPressed) keyEl.classList.add('pressed');
    }
  });
}

function updateRightKeysPhonemic() {
  const rightCode = getRightCode();
  const vowel = VOWELS[rightCode];

  document.querySelectorAll('.key.right').forEach(keyEl => {
    const key = keyEl.dataset.key;
    const isPressed = heldKeys.has(key);
    const labelEl = keyEl.querySelector('.key-label');

    keyEl.classList.remove('pressed', 'has-option', 'action', 'subject', 'quality', 'connect', 'respond', 'symbol', 'style', 'mode', 'phonemic', 'control');

    keyEl.classList.add('has-option', 'phonemic');
    labelEl.textContent = VOWEL_LABELS[key] || '';

    if (isPressed) {
      keyEl.classList.add('pressed', 'phonemic');
    }
  });
}

function updatePreview() {
  const leftCode = getLeftCode();
  const rightCode = getRightCode();

  previewResult.classList.remove('action', 'subject', 'quality', 'connect', 'respond', 'symbol', 'style', 'mode', 'control', 'phonemic', 'empty');

  if (!chordActive || (leftCode === 0 && rightCode === 0)) {
    previewResult.textContent = 'READY';
    previewResult.classList.add('empty');
    return;
  }

  // Mode toggle (S+C+M)
  if (leftCode === 18 && rightCode === 16) {  // S+C = 2+16=18, M = 16
    previewResult.textContent = '⇄ TOGGLE MODE';
    previewResult.classList.add('mode');
    return;
  }

  // Backspace (C+M)
  if (leftCode === 16 && rightCode === 16) {
    previewResult.textContent = '⌫ BACKSPACE';
    previewResult.classList.add('control');
    return;
  }

  // Enter (C+;)
  if (leftCode === 16 && rightCode === 1) {
    previewResult.textContent = '↵ ENTER';
    previewResult.classList.add('control');
    return;
  }

  if (currentMode === 'phonemic') {
    // Show phonemic preview
    const consonant = CONSONANTS[leftCode] || '';
    const vowel = VOWELS[rightCode] || '';
    previewResult.textContent = consonant + vowel || '...';
    previewResult.classList.add('phonemic');
  } else {
    // Show semantic preview
    const chordKey = getChordKey(leftCode, rightCode);
    const sem = chordKey ? lookupSemantic(chordKey) : null;
    if (sem) {
      previewResult.textContent = sem.symbol;
      previewResult.classList.add(sem.category);
    } else if (leftCode > 0) {
      const category = getCurrentCategory();
      previewResult.textContent = category ? category.toUpperCase() + '...' : 'SELECT...';
      previewResult.classList.add(category || 'empty');
    } else {
      previewResult.textContent = 'READY';
      previewResult.classList.add('empty');
    }
  }
}

function flashFired() {
  document.querySelectorAll('.key.pressed').forEach(k => {
    k.classList.add('fired');
    setTimeout(() => k.classList.remove('fired'), 200);
  });
}

function flashInvalid() {
  textOutput.classList.add('invalid-flash');
  setTimeout(() => textOutput.classList.remove('invalid-flash'), 300);
}

// ============================================================
// SERVER COMMUNICATION
// ============================================================

async function checkServer() {
  try {
    const res = await fetch(`${API_BASE}/health`, { signal: AbortSignal.timeout(2000) });
    if (res.ok) {
      serverOnline = true;
      document.getElementById('status-dot').classList.add('online');
      document.getElementById('server-status').textContent = 'Connected';
    }
  } catch {
    serverOnline = false;
    document.getElementById('status-dot').classList.remove('online');
    document.getElementById('server-status').textContent = 'Offline';
  }
}

async function expandSemantic(tokens, options = {}) {
  if (!serverOnline) return tokens.map(t => t.symbol).join(' ');
  try {
    // Format tokens: UPPERCASE = semantic, lowercase = phonemic
    const formattedTokens = tokens.map(t => {
      if (t.isRawIPA) {
        return t.symbol.toLowerCase();  // Phonemic stays lowercase
      }
      return t.symbol.toUpperCase();  // Semantic is UPPERCASE
    });

    const payload = { tokens: formattedTokens };
    if (options.styles && options.styles.length > 0) payload.styles = options.styles;
    if (options.originalText) payload.original_text = options.originalText;

    const res = await fetch(`${API_BASE}/expand`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
      signal: AbortSignal.timeout(15000),
    });
    if (res.ok) {
      const data = await res.json();
      return data.text;
    }
  } catch {
    checkServer();
  }
  return tokens.map(t => t.symbol).join(' ');
}

async function convertPhonemic(ipa) {
  if (!serverOnline) return ipa;
  try {
    const res = await fetch(`${API_BASE}/convert`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ ipa, lang: 'en' }),
      signal: AbortSignal.timeout(15000),
    });
    if (res.ok) {
      const data = await res.json();
      return data.text;
    }
  } catch {
    checkServer();
  }
  return ipa;
}

// ============================================================
// EVENT HANDLERS
// ============================================================

function normalizeKey(e) {
  if (e.key === ';') return ';';
  return e.key.toLowerCase();
}

document.addEventListener('keydown', (e) => {
  if (e.key === ' ') {
    e.preventDefault();
    handleSpace();
    return;
  }

  if (e.key === 'Backspace') {
    e.preventDefault();
    handleBackspace();
    return;
  }

  if (e.key === 'Enter') {
    e.preventDefault();
    handleEnter();
    return;
  }

  const key = normalizeKey(e);
  if (!isChordKey(key)) return;
  e.preventDefault();
  if (expanding) return;
  if (heldKeys.has(key)) return;

  if (!chordActive) {
    chordActive = true;
    chordBuffer.clear();
  }

  heldKeys.add(key);
  chordBuffer.add(key);
  updateKeyVisuals();
  updatePreview();
});

document.addEventListener('keyup', (e) => {
  const key = normalizeKey(e);
  if (!isChordKey(key)) return;
  e.preventDefault();

  heldKeys.delete(key);
  updateKeyVisuals();

  if (chordActive && heldKeys.size === 0) {
    fireChord();
    chordActive = false;
    chordBuffer.clear();
    setTimeout(() => {
      if (!chordActive) {
        updateKeyVisuals();
        updatePreview();
      }
    }, 100);
  }
});

function fireChord() {
  const leftCode = getLeftCode();
  const rightCode = getRightCode();

  // Mode toggle: S+C+M (leftCode = 18 (S=2, C=16), rightCode = 16 (M))
  if (leftCode === 18 && rightCode === 16) {
    flashFired();
    toggleMode();
    return;
  }

  // Backspace: C+M (both thumbs)
  if (leftCode === 16 && rightCode === 16) {
    flashFired();
    handleBackspace();
    return;
  }

  // Enter: C+; (left thumb + right pinky)
  if (leftCode === 16 && rightCode === 1) {
    flashFired();
    handleEnter();
    return;
  }

  if (currentMode === 'phonemic') {
    firePhonemic(leftCode, rightCode);
  } else {
    fireSemantic(leftCode, rightCode);
  }
}

function fireSemantic(leftCode, rightCode) {
  const chordKey = getChordKey(leftCode, rightCode);
  const sem = chordKey ? lookupSemantic(chordKey) : null;

  if (sem) {
    flashFired();
    semanticBuffer.push(sem);
    updateDisplay();
  } else if (leftCode > 0 || rightCode > 0) {
    flashInvalid();
  }
}

function firePhonemic(leftCode, rightCode) {
  let ipa = '';
  let valid = true;

  if (leftCode !== 0) {
    const c = CONSONANTS[leftCode];
    if (c) ipa += c;
    else valid = false;
  }

  if (rightCode !== 0) {
    const v = VOWELS[rightCode];
    if (v) ipa += v;
    else valid = false;
  }

  if (ipa && valid) {
    flashFired();
    phonemicBuffer.push(ipa);
    updateDisplay();
  } else if (!valid) {
    flashInvalid();
  }
}

async function handleSpace() {
  if (currentMode === 'phonemic') {
    // In phonemic mode, Space just locks the IPA and returns to semantic
    // (same as toggle, but more natural)
    toggleMode();
    return;
  }

  // Semantic mode - expand everything including raw IPA
  if (semanticBuffer.length === 0) return;
  if (expanding) return;

  expanding = true;
  document.body.classList.add('expanding');
  updateDisplay();

  const hasReprompt = semanticBuffer.some(t => t.symbol === 'REPROMPT');
  const styleTokens = semanticBuffer.filter(t => t.category === 'style' && t.symbol !== 'REPROMPT');
  const contentTokens = semanticBuffer.filter(t => t.category !== 'style');

  let result;

  if (hasReprompt && lastExpansionTokens.length > 0) {
    result = await expandSemantic(lastExpansionTokens, {
      styles: styleTokens.map(t => t.symbol),
      originalText: lastExpansionResult
    });

    if (completedLines.length > 0) {
      for (let i = completedLines.length - 1; i >= 0; i--) {
        if (completedLines[i].trim() !== '') {
          completedLines[i] = result;
          break;
        }
      }
    }
  } else {
    const options = {};
    if (styleTokens.length > 0) options.styles = styleTokens.map(t => t.symbol);

    // Check if there are phonemic tokens that need conversion
    const hasPhonemic = contentTokens.some(t => t.isRawIPA);
    if (hasPhonemic) {
      options.hasPhonemic = true;
    }

    result = await expandSemantic(contentTokens, options);

    lastExpansionTokens = [...contentTokens];
    lastExpansionResult = result;

    if (completedLines.length > 0 && completedLines[completedLines.length - 1] !== '') {
      completedLines[completedLines.length - 1] += ' ' + result;
    } else if (completedLines.length > 0) {
      completedLines[completedLines.length - 1] = result;
    } else {
      completedLines.push(result);
    }
  }

  expanding = false;
  document.body.classList.remove('expanding');
  semanticBuffer = [];
  updateDisplay();
}

function handleEnter() {
  if (semanticBuffer.length > 0 || phonemicBuffer.length > 0) return;
  completedLines.push('');
  updateDisplay();
}

function handleBackspace() {
  if (expanding) return;

  if (currentMode === 'phonemic') {
    // In phonemic mode, delete from phonemic buffer first
    if (phonemicBuffer.length > 0) {
      phonemicBuffer.pop();
      updateDisplay();
    } else {
      // If phonemic buffer empty, cancel phonemic mode and go back
      phonemicStartIndex = -1;
      setMode('semantic');
    }
  } else if (semanticBuffer.length > 0) {
    semanticBuffer.pop();
    updateDisplay();
  } else if (completedLines.length > 0) {
    completedLines.pop();
    updateDisplay();
  }
}

function handleEnter() {
  // Add a new line to the output
  if (semanticBuffer.length === 0 && phonemicBuffer.length === 0) {
    completedLines.push('');
    updateDisplay();
  }
}

window.addEventListener('blur', () => {
  heldKeys.clear();
  chordBuffer.clear();
  chordActive = false;
  updateKeyVisuals();
  updatePreview();
});

// ============================================================
// INIT
// ============================================================
checkServer();
setInterval(checkServer, 10000);
updateDisplay();
updateKeyVisuals();
updatePreview();
</script>
</body>
</html>
