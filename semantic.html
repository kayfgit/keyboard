<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Semantic Chord Keyboard</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Orbitron:wght@500;700&display=swap" rel="stylesheet">
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }

  :root {
    --bg-deep: #05080a;
    --bg-panel: #0a0e12;
    --bg-surface: #0f1419;
    --border: #1a2332;
    --border-glow: #2a3a4a;

    --text-dim: #3a4a5a;
    --text-mid: #6a7a8a;
    --text-bright: #c5d5e5;

    --action: #00d4ff;
    --action-glow: rgba(0, 212, 255, 0.4);
    --subject: #bf5fff;
    --subject-glow: rgba(191, 95, 255, 0.4);
    --quality: #ffb800;
    --quality-glow: rgba(255, 184, 0, 0.4);
    --connect: #00ffa3;
    --connect-glow: rgba(0, 255, 163, 0.4);
    --respond: #ff5f87;
    --respond-glow: rgba(255, 95, 135, 0.4);
    --symbol: #8b9dc3;
    --symbol-glow: rgba(139, 157, 195, 0.4);
    --style: #ff9f43;
    --style-glow: rgba(255, 159, 67, 0.4);
    --mode: #a29bfe;
    --mode-glow: rgba(162, 155, 254, 0.4);

    --accent: #00ffa3;
    --accent-glow: rgba(0, 255, 163, 0.3);
  }

  body {
    font-family: 'JetBrains Mono', monospace;
    background: var(--bg-deep);
    color: var(--text-bright);
    height: 100vh;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }

  /* Scanline overlay */
  body::before {
    content: '';
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: repeating-linear-gradient(
      0deg,
      transparent,
      transparent 2px,
      rgba(0, 0, 0, 0.1) 2px,
      rgba(0, 0, 0, 0.1) 4px
    );
    pointer-events: none;
    z-index: 1000;
  }

  /* Status bar */
  #status-bar {
    padding: 8px 20px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    background: var(--bg-panel);
    border-bottom: 1px solid var(--border);
    font-size: 11px;
    letter-spacing: 0.5px;
  }

  .status-indicator {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .status-dot {
    width: 6px;
    height: 6px;
    border-radius: 50%;
    background: var(--text-dim);
    box-shadow: 0 0 6px transparent;
    transition: all 0.3s ease;
  }

  .status-dot.online {
    background: var(--accent);
    box-shadow: 0 0 8px var(--accent-glow);
  }

  #mode-label {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    font-weight: 700;
    letter-spacing: 3px;
    color: var(--accent);
    text-shadow: 0 0 10px var(--accent-glow);
  }

  /* Output area */
  #output-area {
    flex: 1;
    padding: 16px 20px;
    display: flex;
    flex-direction: column;
    min-height: 0;
    max-height: 30vh;
  }

  .section-label {
    font-size: 9px;
    font-weight: 600;
    letter-spacing: 2px;
    color: var(--text-dim);
    margin-bottom: 8px;
    text-transform: uppercase;
  }

  #text-output {
    flex: 1;
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 4px;
    padding: 16px;
    font-size: 16px;
    line-height: 1.7;
    color: var(--text-bright);
    overflow-y: auto;
    word-wrap: break-word;
    white-space: pre-wrap;
  }

  #text-output .cursor {
    display: inline-block;
    width: 8px;
    height: 1.2em;
    background: var(--accent);
    vertical-align: text-bottom;
    animation: cursorBlink 1s step-end infinite;
    box-shadow: 0 0 8px var(--accent-glow);
  }

  @keyframes cursorBlink {
    50% { opacity: 0; }
  }

  .expanding #text-output {
    border-color: var(--accent);
    box-shadow: 0 0 20px var(--accent-glow), inset 0 0 30px rgba(0, 255, 163, 0.05);
  }

  /* Intent buffer */
  #intent-buffer {
    padding: 12px 20px;
    background: var(--bg-panel);
    border-top: 1px solid var(--border);
    min-height: 52px;
  }

  #intent-display {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
    min-height: 28px;
  }

  .intent-token {
    padding: 4px 12px;
    border-radius: 2px;
    font-size: 12px;
    font-weight: 600;
    letter-spacing: 0.5px;
    text-transform: uppercase;
    border: 1px solid;
    transition: all 0.15s ease;
  }

  .intent-token.action {
    color: var(--action);
    border-color: var(--action);
    background: rgba(0, 212, 255, 0.1);
    box-shadow: 0 0 10px var(--action-glow);
  }
  .intent-token.subject {
    color: var(--subject);
    border-color: var(--subject);
    background: rgba(191, 95, 255, 0.1);
    box-shadow: 0 0 10px var(--subject-glow);
  }
  .intent-token.quality {
    color: var(--quality);
    border-color: var(--quality);
    background: rgba(255, 184, 0, 0.1);
    box-shadow: 0 0 10px var(--quality-glow);
  }
  .intent-token.connect {
    color: var(--connect);
    border-color: var(--connect);
    background: rgba(0, 255, 163, 0.1);
    box-shadow: 0 0 10px var(--connect-glow);
  }
  .intent-token.respond {
    color: var(--respond);
    border-color: var(--respond);
    background: rgba(255, 95, 135, 0.1);
    box-shadow: 0 0 10px var(--respond-glow);
  }
  .intent-token.symbol {
    color: var(--symbol);
    border-color: var(--symbol);
    background: rgba(139, 157, 195, 0.1);
    box-shadow: 0 0 10px var(--symbol-glow);
  }
  .intent-token.style {
    color: var(--style);
    border-color: var(--style);
    background: rgba(255, 159, 67, 0.1);
    box-shadow: 0 0 10px var(--style-glow);
  }
  .intent-token.mode {
    color: var(--mode);
    border-color: var(--mode);
    background: rgba(162, 155, 254, 0.1);
    box-shadow: 0 0 10px var(--mode-glow);
  }
  .intent-token.phonemic {
    color: #9b7bf7;
    border-color: #9b7bf7;
    background: rgba(155, 123, 247, 0.1);
    box-shadow: 0 0 10px rgba(155, 123, 247, 0.4);
    font-style: italic;
  }

  .intent-placeholder {
    color: var(--text-dim);
    font-size: 11px;
    letter-spacing: 1px;
  }

  /* Chord preview - current selection */
  #chord-preview {
    padding: 16px 20px;
    background: var(--bg-surface);
    border-top: 1px solid var(--border);
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 20px;
    min-height: 60px;
  }

  #preview-result {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    font-weight: 700;
    letter-spacing: 2px;
    min-width: 200px;
    text-align: center;
    transition: all 0.15s ease;
  }

  #preview-result.action { color: var(--action); text-shadow: 0 0 15px var(--action-glow); }
  #preview-result.subject { color: var(--subject); text-shadow: 0 0 15px var(--subject-glow); }
  #preview-result.quality { color: var(--quality); text-shadow: 0 0 15px var(--quality-glow); }
  #preview-result.connect { color: var(--connect); text-shadow: 0 0 15px var(--connect-glow); }
  #preview-result.respond { color: var(--respond); text-shadow: 0 0 15px var(--respond-glow); }
  #preview-result.symbol { color: var(--symbol); text-shadow: 0 0 15px var(--symbol-glow); }
  #preview-result.style { color: var(--style); text-shadow: 0 0 15px var(--style-glow); }
  #preview-result.mode { color: var(--mode); text-shadow: 0 0 15px var(--mode-glow); }
  #preview-result.control { color: var(--accent); text-shadow: 0 0 15px var(--accent-glow); }
  #preview-result.empty { color: var(--text-dim); text-shadow: none; }

  /* Keyboard area */
  #keyboard-area {
    padding: 20px;
    background: var(--bg-panel);
    border-top: 1px solid var(--border);
  }

  .keyboard-container {
    display: flex;
    justify-content: center;
    gap: 40px;
    max-width: 900px;
    margin: 0 auto;
  }

  .hand {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .hand-header {
    text-align: center;
    padding-bottom: 8px;
    border-bottom: 1px solid var(--border);
  }

  .hand-title {
    font-family: 'Orbitron', sans-serif;
    font-size: 10px;
    font-weight: 500;
    letter-spacing: 2px;
    color: var(--text-mid);
    text-transform: uppercase;
  }

  .keys-row {
    display: flex;
    gap: 8px;
  }

  /* Key styling */
  .key {
    width: 72px;
    height: 80px;
    border-radius: 6px;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    background: var(--bg-surface);
    border: 1px solid var(--border);
    transition: all 0.12s ease;
    cursor: default;
    position: relative;
    overflow: hidden;
  }

  .key::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    right: 0;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--border-glow), transparent);
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  .key .key-letter {
    font-family: 'Orbitron', sans-serif;
    font-size: 18px;
    font-weight: 700;
    color: var(--text-dim);
    transition: all 0.12s ease;
  }

  .key .key-label {
    font-size: 8px;
    font-weight: 600;
    letter-spacing: 1px;
    color: var(--text-dim);
    margin-top: 4px;
    text-transform: uppercase;
    transition: all 0.12s ease;
    max-width: 64px;
    text-align: center;
    line-height: 1.2;
    min-height: 20px;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  /* Left hand key states */
  .key.left.available {
    border-color: var(--border-glow);
  }
  .key.left.available::before { opacity: 1; }

  .key.left.pressed {
    transform: translateY(2px);
  }

  .key.left.pressed.action {
    background: rgba(0, 212, 255, 0.15);
    border-color: var(--action);
    box-shadow: 0 0 20px var(--action-glow), inset 0 0 20px rgba(0, 212, 255, 0.1);
  }
  .key.left.pressed.action .key-letter { color: var(--action); }
  .key.left.pressed.action .key-label { color: var(--action); }

  .key.left.pressed.subject {
    background: rgba(191, 95, 255, 0.15);
    border-color: var(--subject);
    box-shadow: 0 0 20px var(--subject-glow), inset 0 0 20px rgba(191, 95, 255, 0.1);
  }
  .key.left.pressed.subject .key-letter { color: var(--subject); }
  .key.left.pressed.subject .key-label { color: var(--subject); }

  .key.left.pressed.quality {
    background: rgba(255, 184, 0, 0.15);
    border-color: var(--quality);
    box-shadow: 0 0 20px var(--quality-glow), inset 0 0 20px rgba(255, 184, 0, 0.1);
  }
  .key.left.pressed.quality .key-letter { color: var(--quality); }
  .key.left.pressed.quality .key-label { color: var(--quality); }

  .key.left.pressed.connect {
    background: rgba(0, 255, 163, 0.15);
    border-color: var(--connect);
    box-shadow: 0 0 20px var(--connect-glow), inset 0 0 20px rgba(0, 255, 163, 0.1);
  }
  .key.left.pressed.connect .key-letter { color: var(--connect); }
  .key.left.pressed.connect .key-label { color: var(--connect); }

  .key.left.pressed.respond {
    background: rgba(255, 95, 135, 0.15);
    border-color: var(--respond);
    box-shadow: 0 0 20px var(--respond-glow), inset 0 0 20px rgba(255, 95, 135, 0.1);
  }
  .key.left.pressed.respond .key-letter { color: var(--respond); }
  .key.left.pressed.respond .key-label { color: var(--respond); }

  .key.left.pressed.symbol {
    background: rgba(139, 157, 195, 0.15);
    border-color: var(--symbol);
    box-shadow: 0 0 20px var(--symbol-glow), inset 0 0 20px rgba(139, 157, 195, 0.1);
  }
  .key.left.pressed.symbol .key-letter { color: var(--symbol); }
  .key.left.pressed.symbol .key-label { color: var(--symbol); }

  .key.left.pressed.style {
    background: rgba(255, 159, 67, 0.15);
    border-color: var(--style);
    box-shadow: 0 0 20px var(--style-glow), inset 0 0 20px rgba(255, 159, 67, 0.1);
  }
  .key.left.pressed.style .key-letter { color: var(--style); }
  .key.left.pressed.style .key-label { color: var(--style); }

  .key.left.pressed.mode {
    background: rgba(162, 155, 254, 0.15);
    border-color: var(--mode);
    box-shadow: 0 0 20px var(--mode-glow), inset 0 0 20px rgba(162, 155, 254, 0.1);
  }
  .key.left.pressed.mode .key-letter { color: var(--mode); }
  .key.left.pressed.mode .key-label { color: var(--mode); }

  /* Right hand - shows available options */
  .key.right {
    height: 80px;
  }

  .key.right .key-label {
    font-size: 9px;
    min-height: 24px;
    opacity: 0;
    transform: translateY(4px);
    transition: all 0.15s ease;
  }

  .key.right.has-option .key-label {
    opacity: 1;
    transform: translateY(0);
  }

  .key.right.has-option {
    border-color: var(--border-glow);
  }
  .key.right.has-option::before { opacity: 1; }

  .key.right.has-option.action .key-label { color: var(--action); }
  .key.right.has-option.subject .key-label { color: var(--subject); }
  .key.right.has-option.quality .key-label { color: var(--quality); }
  .key.right.has-option.connect .key-label { color: var(--connect); }
  .key.right.has-option.respond .key-label { color: var(--respond); }
  .key.right.has-option.symbol .key-label { color: var(--symbol); }
  .key.right.has-option.style .key-label { color: var(--style); }
  .key.right.has-option.mode .key-label { color: var(--mode); }

  .key.right.pressed {
    transform: translateY(2px);
  }

  .key.right.pressed.action {
    background: rgba(0, 212, 255, 0.2);
    border-color: var(--action);
    box-shadow: 0 0 25px var(--action-glow);
  }
  .key.right.pressed.action .key-letter { color: var(--action); }

  .key.right.pressed.subject {
    background: rgba(191, 95, 255, 0.2);
    border-color: var(--subject);
    box-shadow: 0 0 25px var(--subject-glow);
  }
  .key.right.pressed.subject .key-letter { color: var(--subject); }

  .key.right.pressed.quality {
    background: rgba(255, 184, 0, 0.2);
    border-color: var(--quality);
    box-shadow: 0 0 25px var(--quality-glow);
  }
  .key.right.pressed.quality .key-letter { color: var(--quality); }

  .key.right.pressed.connect {
    background: rgba(0, 255, 163, 0.2);
    border-color: var(--connect);
    box-shadow: 0 0 25px var(--connect-glow);
  }
  .key.right.pressed.connect .key-letter { color: var(--connect); }

  .key.right.pressed.respond {
    background: rgba(255, 95, 135, 0.2);
    border-color: var(--respond);
    box-shadow: 0 0 25px var(--respond-glow);
  }
  .key.right.pressed.respond .key-letter { color: var(--respond); }

  .key.right.pressed.symbol {
    background: rgba(139, 157, 195, 0.2);
    border-color: var(--symbol);
    box-shadow: 0 0 25px var(--symbol-glow);
  }
  .key.right.pressed.symbol .key-letter { color: var(--symbol); }

  .key.right.pressed.style {
    background: rgba(255, 159, 67, 0.2);
    border-color: var(--style);
    box-shadow: 0 0 25px var(--style-glow);
  }
  .key.right.pressed.style .key-letter { color: var(--style); }

  .key.right.pressed.mode {
    background: rgba(162, 155, 254, 0.2);
    border-color: var(--mode);
    box-shadow: 0 0 25px var(--mode-glow);
  }
  .key.right.pressed.mode .key-letter { color: var(--mode); }

  .key.right.pressed.control {
    background: rgba(0, 255, 163, 0.2);
    border-color: var(--accent);
    box-shadow: 0 0 25px var(--accent-glow);
  }
  .key.right.pressed.control .key-letter { color: var(--accent); }
  .key.right.pressed.control .key-label { color: var(--accent); }

  /* Fired animation */
  .key.fired {
    animation: keyFire 0.2s ease;
  }

  @keyframes keyFire {
    0% { transform: scale(1); }
    50% { transform: scale(0.95); }
    100% { transform: scale(1); }
  }

  /* Help bar */
  #help-bar {
    padding: 10px 20px;
    background: var(--bg-deep);
    border-top: 1px solid var(--border);
    display: flex;
    justify-content: center;
    gap: 24px;
    font-size: 10px;
    color: var(--text-dim);
  }

  #help-bar kbd {
    display: inline-block;
    padding: 2px 6px;
    background: var(--bg-surface);
    border: 1px solid var(--border);
    border-radius: 3px;
    font-family: 'JetBrains Mono', monospace;
    font-size: 9px;
    color: var(--text-mid);
    margin: 0 2px;
  }

  #help-bar a {
    color: var(--accent);
    text-decoration: none;
  }

  /* Options panel - shows all available options for current state */
  #options-panel {
    padding: 12px 20px;
    background: var(--bg-surface);
    border-top: 1px solid var(--border);
    display: none;
  }

  #options-panel.visible {
    display: block;
  }

  .options-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
    gap: 6px;
    max-height: 120px;
    overflow-y: auto;
  }

  .option-item {
    padding: 6px 10px;
    background: var(--bg-panel);
    border: 1px solid var(--border);
    border-radius: 3px;
    font-size: 10px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    gap: 8px;
  }

  .option-item .chord {
    color: var(--text-dim);
    font-size: 9px;
  }

  .option-item .symbol {
    font-weight: 600;
  }

  .option-item.action .symbol { color: var(--action); }
  .option-item.target .symbol { color: var(--target); }
  .option-item.modifier .symbol { color: var(--modifier); }
  .option-item.logic .symbol { color: var(--logic); }
  .option-item.meta .symbol { color: var(--meta); }

  /* Invalid flash */
  .invalid-flash {
    animation: invalidShake 0.3s ease;
  }

  @keyframes invalidShake {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-4px); }
    75% { transform: translateX(4px); }
  }

  /* Scrollbar */
  ::-webkit-scrollbar {
    width: 6px;
  }
  ::-webkit-scrollbar-track {
    background: var(--bg-surface);
  }
  ::-webkit-scrollbar-thumb {
    background: var(--border);
    border-radius: 3px;
  }
  ::-webkit-scrollbar-thumb:hover {
    background: var(--border-glow);
  }
</style>
</head>
<body>

<div id="status-bar">
  <div class="status-indicator">
    <span class="status-dot" id="status-dot"></span>
    <span id="server-status">Checking server...</span>
  </div>
  <span id="mode-label">SEMANTIC MODE</span>
  <span style="color: var(--text-dim);">Universal Intent Interface</span>
</div>

<div id="output-area">
  <div class="section-label">Output</div>
  <div id="text-output"><span class="cursor"></span></div>
</div>

<div id="intent-buffer">
  <div id="intent-display">
    <span class="intent-placeholder">Hold category key to see options...</span>
  </div>
</div>

<div id="chord-preview">
  <div id="preview-result" class="empty">READY</div>
</div>

<div id="options-panel">
  <div class="options-grid" id="options-grid"></div>
</div>

<div id="keyboard-area">
  <div class="keyboard-container">
    <div class="hand" id="left-hand">
      <div class="hand-header">
        <div class="hand-title">Category Select</div>
      </div>
      <div class="keys-row">
        <div class="key left" id="key-a" data-key="a" data-category="action">
          <span class="key-letter">A</span>
          <span class="key-label">ACTION</span>
        </div>
        <div class="key left" id="key-s" data-key="s" data-category="subject">
          <span class="key-letter">S</span>
          <span class="key-label">SUBJECT</span>
        </div>
        <div class="key left" id="key-d" data-key="d" data-category="quality">
          <span class="key-letter">D</span>
          <span class="key-label">QUALITY</span>
        </div>
        <div class="key left" id="key-f" data-key="f" data-category="connect">
          <span class="key-letter">F</span>
          <span class="key-label">CONNECT</span>
        </div>
        <div class="key left" id="key-c" data-key="c" data-category="respond">
          <span class="key-letter">C</span>
          <span class="key-label">RESPOND</span>
        </div>
      </div>
    </div>

    <div class="hand" id="right-hand">
      <div class="hand-header">
        <div class="hand-title">Command Select</div>
      </div>
      <div class="keys-row">
        <div class="key right" id="key-m" data-key="m">
          <span class="key-letter">M</span>
          <span class="key-label">EXTEND</span>
        </div>
        <div class="key right" id="key-j" data-key="j">
          <span class="key-letter">J</span>
          <span class="key-label"></span>
        </div>
        <div class="key right" id="key-k" data-key="k">
          <span class="key-letter">K</span>
          <span class="key-label"></span>
        </div>
        <div class="key right" id="key-l" data-key="l">
          <span class="key-letter">L</span>
          <span class="key-label"></span>
        </div>
        <div class="key right" id="key-semicolon" data-key=";">
          <span class="key-letter">;</span>
          <span class="key-label"></span>
        </div>
      </div>
    </div>
  </div>
</div>

<div id="help-bar">
  <span><kbd>Space</kbd> Expand to text</span>
  <span><kbd>D</kbd>+<kbd>C</kbd> Style modifiers</span>
  <span><kbd>A</kbd>+<kbd>F</kbd> Symbols</span>
  <span><kbd>Backspace</kbd> Delete token</span>
  <a href="semantic-cheatsheet.html">Full Reference</a>
</div>

<script>
// ============================================================
// SEMANTIC VOCABULARY
// ============================================================

const SEMANTICS = {
  // ============================================================
  // ACTIONS (A) - General verbs for doing things
  // ============================================================
  'A+J':       { symbol: 'MAKE', category: 'action' },
  'A+K':       { symbol: 'CHANGE', category: 'action' },
  'A+L':       { symbol: 'REMOVE', category: 'action' },
  'A+;':       { symbol: 'FIX', category: 'action' },
  'A+J+K':     { symbol: 'FIND', category: 'action' },
  'A+J+L':     { symbol: 'SHOW', category: 'action' },
  'A+J+;':     { symbol: 'TRY', category: 'action' },
  'A+K+L':     { symbol: 'USE', category: 'action' },
  'A+K+;':     { symbol: 'EXPLAIN', category: 'action' },
  'A+L+;':     { symbol: 'IMPROVE', category: 'action' },
  'A+J+K+L':   { symbol: 'COMPARE', category: 'action' },
  'A+J+K+;':   { symbol: 'ANALYZE', category: 'action' },
  'A+J+L+;':   { symbol: 'SUMMARIZE', category: 'action' },
  'A+K+L+;':   { symbol: 'EXPAND', category: 'action' },
  'A+J+K+L+;': { symbol: 'SIMPLIFY', category: 'action' },
  // Extended actions (M+)
  'A+M+J':     { symbol: 'ADD', category: 'action' },
  'A+M+K':     { symbol: 'KEEP', category: 'action' },
  'A+M+L':     { symbol: 'GIVE', category: 'action' },
  'A+M+;':     { symbol: 'TAKE', category: 'action' },
  'A+M+J+K':   { symbol: 'THINK', category: 'action' },
  'A+M+J+L':   { symbol: 'HELP', category: 'action' },
  'A+M+J+;':   { symbol: 'CHECK', category: 'action' },
  'A+M+K+L':   { symbol: 'LIST', category: 'action' },
  'A+M+K+;':   { symbol: 'COMBINE', category: 'action' },
  'A+M+L+;':   { symbol: 'SPLIT', category: 'action' },
  'A+M+J+K+L': { symbol: 'GENERATE', category: 'action' },
  'A+M+J+K+;': { symbol: 'TRANSLATE', category: 'action' },
  'A+M+J+L+;': { symbol: 'REWRITE', category: 'action' },
  'A+M+K+L+;': { symbol: 'FORMAT', category: 'action' },

  // ============================================================
  // SUBJECTS (S) - Things you talk about
  // ============================================================
  'S+J':       { symbol: 'THIS', category: 'subject' },
  'S+K':       { symbol: 'THAT', category: 'subject' },
  'S+L':       { symbol: 'IT', category: 'subject' },
  'S+;':       { symbol: 'IDEA', category: 'subject' },
  'S+J+K':     { symbol: 'TEXT', category: 'subject' },
  'S+J+L':     { symbol: 'CODE', category: 'subject' },
  'S+J+;':     { symbol: 'QUESTION', category: 'subject' },
  'S+K+L':     { symbol: 'ANSWER', category: 'subject' },
  'S+K+;':     { symbol: 'PROBLEM', category: 'subject' },
  'S+L+;':     { symbol: 'SOLUTION', category: 'subject' },
  'S+J+K+L':   { symbol: 'EXAMPLE', category: 'subject' },
  'S+J+K+;':   { symbol: 'RESULT', category: 'subject' },
  'S+J+L+;':   { symbol: 'REASON', category: 'subject' },
  'S+K+L+;':   { symbol: 'WAY', category: 'subject' },
  'S+J+K+L+;': { symbol: 'POINT', category: 'subject' },
  // Extended subjects (M+)
  'S+M+J':     { symbol: 'FILE', category: 'subject' },
  'S+M+K':     { symbol: 'FUNCTION', category: 'subject' },
  'S+M+L':     { symbol: 'DATA', category: 'subject' },
  'S+M+;':     { symbol: 'NAME', category: 'subject' },
  'S+M+J+K':   { symbol: 'LIST', category: 'subject' },
  'S+M+J+L':   { symbol: 'STEP', category: 'subject' },
  'S+M+J+;':   { symbol: 'PART', category: 'subject' },
  'S+M+K+L':   { symbol: 'OPTION', category: 'subject' },
  'S+M+K+;':   { symbol: 'ERROR', category: 'subject' },
  'S+M+L+;':   { symbol: 'OUTPUT', category: 'subject' },
  'S+M+J+K+L': { symbol: 'INPUT', category: 'subject' },
  'S+M+J+K+;': { symbol: 'CONTENT', category: 'subject' },
  'S+M+J+L+;': { symbol: 'CONTEXT', category: 'subject' },
  'S+M+K+L+;': { symbol: 'DETAIL', category: 'subject' },

  // ============================================================
  // QUALITY (D) - Descriptors and adjectives
  // ============================================================
  'D+J':       { symbol: 'GOOD', category: 'quality' },
  'D+K':       { symbol: 'BAD', category: 'quality' },
  'D+L':       { symbol: 'MORE', category: 'quality' },
  'D+;':       { symbol: 'LESS', category: 'quality' },
  'D+J+K':     { symbol: 'SIMPLE', category: 'quality' },
  'D+J+L':     { symbol: 'COMPLEX', category: 'quality' },
  'D+J+;':     { symbol: 'NEW', category: 'quality' },
  'D+K+L':     { symbol: 'OLD', category: 'quality' },
  'D+K+;':     { symbol: 'SAME', category: 'quality' },
  'D+L+;':     { symbol: 'DIFFERENT', category: 'quality' },
  'D+J+K+L':   { symbol: 'GENERAL', category: 'quality' },
  'D+J+K+;':   { symbol: 'SPECIFIC', category: 'quality' },
  'D+J+L+;':   { symbol: 'MAIN', category: 'quality' },
  'D+K+L+;':   { symbol: 'OTHER', category: 'quality' },
  'D+J+K+L+;': { symbol: 'ALL', category: 'quality' },
  // Extended qualities (M+)
  'D+M+J':     { symbol: 'FAST', category: 'quality' },
  'D+M+K':     { symbol: 'SLOW', category: 'quality' },
  'D+M+L':     { symbol: 'BIG', category: 'quality' },
  'D+M+;':     { symbol: 'SMALL', category: 'quality' },
  'D+M+J+K':   { symbol: 'SHORT', category: 'quality' },
  'D+M+J+L':   { symbol: 'LONG', category: 'quality' },
  'D+M+J+;':   { symbol: 'CLEAR', category: 'quality' },
  'D+M+K+L':   { symbol: 'BETTER', category: 'quality' },
  'D+M+K+;':   { symbol: 'WORSE', category: 'quality' },
  'D+M+L+;':   { symbol: 'CORRECT', category: 'quality' },
  'D+M+J+K+L': { symbol: 'WRONG', category: 'quality' },
  'D+M+J+K+;': { symbol: 'SIMILAR', category: 'quality' },
  'D+M+J+L+;': { symbol: 'EXACT', category: 'quality' },
  'D+M+K+L+;': { symbol: 'ENOUGH', category: 'quality' },

  // ============================================================
  // CONNECT (F) - Connectors and flow
  // ============================================================
  'F+J':       { symbol: 'AND', category: 'connect' },
  'F+K':       { symbol: 'OR', category: 'connect' },
  'F+L':       { symbol: 'BUT', category: 'connect' },
  'F+;':       { symbol: 'SO', category: 'connect' },
  'F+J+K':     { symbol: 'IF', category: 'connect' },
  'F+J+L':     { symbol: 'THEN', category: 'connect' },
  'F+J+;':     { symbol: 'BECAUSE', category: 'connect' },
  'F+K+L':     { symbol: 'WITH', category: 'connect' },
  'F+K+;':     { symbol: 'WITHOUT', category: 'connect' },
  'F+L+;':     { symbol: 'FOR', category: 'connect' },
  'F+J+K+L':   { symbol: 'TO', category: 'connect' },
  'F+J+K+;':   { symbol: 'FROM', category: 'connect' },
  'F+J+L+;':   { symbol: 'LIKE', category: 'connect' },
  'F+K+L+;':   { symbol: 'AS', category: 'connect' },
  'F+J+K+L+;': { symbol: 'ABOUT', category: 'connect' },
  // Extended connectors (M+)
  'F+M+J':     { symbol: 'ALSO', category: 'connect' },
  'F+M+K':     { symbol: 'HOWEVER', category: 'connect' },
  'F+M+L':     { symbol: 'INSTEAD', category: 'connect' },
  'F+M+;':     { symbol: 'RATHER', category: 'connect' },
  'F+M+J+K':   { symbol: 'BEFORE', category: 'connect' },
  'F+M+J+L':   { symbol: 'AFTER', category: 'connect' },
  'F+M+J+;':   { symbol: 'WHILE', category: 'connect' },
  'F+M+K+L':   { symbol: 'WHEN', category: 'connect' },
  'F+M+K+;':   { symbol: 'WHERE', category: 'connect' },
  'F+M+L+;':   { symbol: 'ALTHOUGH', category: 'connect' },
  'F+M+J+K+L': { symbol: 'UNLESS', category: 'connect' },
  'F+M+J+K+;': { symbol: 'UNTIL', category: 'connect' },
  'F+M+J+L+;': { symbol: 'SINCE', category: 'connect' },
  'F+M+K+L+;': { symbol: 'WHETHER', category: 'connect' },

  // ============================================================
  // RESPOND (C) - Feedback, questions, meta
  // ============================================================
  'C+J':       { symbol: 'YES', category: 'respond' },
  'C+K':       { symbol: 'NO', category: 'respond' },
  'C+L':       { symbol: 'MAYBE', category: 'respond' },
  'C+;':       { symbol: 'OK', category: 'respond' },
  'C+J+K':     { symbol: 'THANKS', category: 'respond' },
  'C+J+L':     { symbol: 'PLEASE', category: 'respond' },
  'C+J+;':     { symbol: 'SORRY', category: 'respond' },
  'C+K+L':     { symbol: 'WAIT', category: 'respond' },
  'C+K+;':     { symbol: 'DONE', category: 'respond' },
  'C+L+;':     { symbol: 'AGAIN', category: 'respond' },
  'C+J+K+L':   { symbol: 'WHAT', category: 'respond' },
  'C+J+K+;':   { symbol: 'WHY', category: 'respond' },
  'C+J+L+;':   { symbol: 'HOW', category: 'respond' },
  'C+K+L+;':   { symbol: 'WHICH', category: 'respond' },
  'C+J+K+L+;': { symbol: 'WHO', category: 'respond' },
  // Extended respond (M+)
  'C+M+J':     { symbol: 'CONTINUE', category: 'respond' },
  'C+M+K':     { symbol: 'STOP', category: 'respond' },
  'C+M+L':     { symbol: 'UNDO', category: 'respond' },
  'C+M+;':     { symbol: 'SKIP', category: 'respond' },
  'C+M+J+K':   { symbol: 'FOCUS', category: 'respond' },
  'C+M+J+L':   { symbol: 'IGNORE', category: 'respond' },
  'C+M+J+;':   { symbol: 'REMEMBER', category: 'respond' },
  'C+M+K+L':   { symbol: 'FORGET', category: 'respond' },
  'C+M+K+;':   { symbol: 'CONFIRM', category: 'respond' },
  'C+M+L+;':   { symbol: 'NEVERMIND', category: 'respond' },
  'C+M+J+K+L': { symbol: 'PERFECT', category: 'respond' },
  'C+M+J+K+;': { symbol: 'ALMOST', category: 'respond' },
  'C+M+J+L+;': { symbol: 'NOT_QUITE', category: 'respond' },
  'C+M+K+L+;': { symbol: 'EXACTLY', category: 'respond' },

  // ============================================================
  // SYMBOLS (A+F) - Numbers and punctuation
  // ============================================================
  'A+F+J':       { symbol: '1', category: 'symbol' },
  'A+F+K':       { symbol: '2', category: 'symbol' },
  'A+F+L':       { symbol: '3', category: 'symbol' },
  'A+F+;':       { symbol: '4', category: 'symbol' },
  'A+F+J+K':     { symbol: '5', category: 'symbol' },
  'A+F+J+L':     { symbol: '6', category: 'symbol' },
  'A+F+J+;':     { symbol: '7', category: 'symbol' },
  'A+F+K+L':     { symbol: '8', category: 'symbol' },
  'A+F+K+;':     { symbol: '9', category: 'symbol' },
  'A+F+L+;':     { symbol: '0', category: 'symbol' },
  'A+F+J+K+L':   { symbol: '.', category: 'symbol' },
  'A+F+J+K+;':   { symbol: ',', category: 'symbol' },
  'A+F+J+L+;':   { symbol: '?', category: 'symbol' },
  'A+F+K+L+;':   { symbol: '!', category: 'symbol' },
  'A+F+J+K+L+;': { symbol: ':', category: 'symbol' },
  // Extended symbols (M+)
  'A+F+M+J':     { symbol: '-', category: 'symbol' },
  'A+F+M+K':     { symbol: '_', category: 'symbol' },
  'A+F+M+L':     { symbol: '/', category: 'symbol' },
  'A+F+M+;':     { symbol: '@', category: 'symbol' },
  'A+F+M+J+K':   { symbol: '#', category: 'symbol' },
  'A+F+M+J+L':   { symbol: '$', category: 'symbol' },
  'A+F+M+J+;':   { symbol: '%', category: 'symbol' },
  'A+F+M+K+L':   { symbol: '&', category: 'symbol' },
  'A+F+M+K+;':   { symbol: '*', category: 'symbol' },
  'A+F+M+L+;':   { symbol: '+', category: 'symbol' },
  'A+F+M+J+K+L': { symbol: '=', category: 'symbol' },
  'A+F+M+J+K+;': { symbol: '(', category: 'symbol' },
  'A+F+M+J+L+;': { symbol: ')', category: 'symbol' },
  'A+F+M+K+L+;': { symbol: '"', category: 'symbol' },

  // ============================================================
  // SHORTCUTS - Common combos
  // ============================================================
  // A+S = Quick actions on subjects
  'A+S+J':       { symbol: 'MAKE_THIS', category: 'action' },
  'A+S+K':       { symbol: 'CHANGE_THIS', category: 'action' },
  'A+S+L':       { symbol: 'EXPLAIN_THIS', category: 'action' },
  'A+S+;':       { symbol: 'FIX_THIS', category: 'action' },
  'A+S+J+K':     { symbol: 'SHOW_ME', category: 'action' },
  'A+S+J+L':     { symbol: 'HELP_ME', category: 'action' },
  'A+S+K+L':     { symbol: 'TELL_ME', category: 'action' },

  // D+S = Quality + subject
  'D+S+J':       { symbol: 'MORE_DETAIL', category: 'quality' },
  'D+S+K':       { symbol: 'LESS_DETAIL', category: 'quality' },
  'D+S+L':       { symbol: 'ANOTHER_WAY', category: 'quality' },
  'D+S+;':       { symbol: 'SAME_THING', category: 'quality' },

  // S+D = Subject qualities
  'S+D+J':       { symbol: 'GOOD_IDEA', category: 'subject' },
  'S+D+K':       { symbol: 'BAD_IDEA', category: 'subject' },
  'S+D+L':       { symbol: 'MAIN_POINT', category: 'subject' },

  // ============================================================
  // STYLE MODIFIERS (D+C) - For reprompting with different tone
  // ============================================================
  'D+C+J':       { symbol: 'FORMAL', category: 'style' },
  'D+C+K':       { symbol: 'CASUAL', category: 'style' },
  'D+C+L':       { symbol: 'POLITE', category: 'style' },
  'D+C+;':       { symbol: 'DIRECT', category: 'style' },
  'D+C+J+K':     { symbol: 'TECHNICAL', category: 'style' },
  'D+C+J+L':     { symbol: 'FRIENDLY', category: 'style' },
  'D+C+J+;':     { symbol: 'PROFESSIONAL', category: 'style' },
  'D+C+K+L':     { symbol: 'BRIEF', category: 'style' },
  'D+C+K+;':     { symbol: 'DETAILED', category: 'style' },
  'D+C+L+;':     { symbol: 'AS_QUESTION', category: 'style' },
  'D+C+J+K+L':   { symbol: 'AS_COMMAND', category: 'style' },
  'D+C+J+K+;':   { symbol: 'AS_REQUEST', category: 'style' },
  'D+C+M+J':     { symbol: 'REPROMPT', category: 'style' },

  // ============================================================
  // HYBRID MODE (S+C) - Switch to phonemic input
  // ============================================================
  'S+C+J':       { symbol: '[PHONEMIC]', category: 'mode' },
};

// Normalize chord key for consistent lookup
const LEFT_KEY_ORDER = ['A', 'S', 'D', 'F', 'C'];
const RIGHT_KEY_ORDER = ['M', 'J', 'K', 'L', ';'];

function sortByOrder(keys, order) {
  return keys.slice().sort((a, b) => order.indexOf(a) - order.indexOf(b));
}

function normalizeChordKey(leftKeys, rightKeys) {
  const sortedLeft = sortByOrder(leftKeys, LEFT_KEY_ORDER);
  const sortedRight = sortByOrder(rightKeys, RIGHT_KEY_ORDER);
  return sortedLeft.join('+') + '+' + sortedRight.join('+');
}

// Build normalized lookup table at startup
const SEMANTICS_LOOKUP = {};
for (const [chord, data] of Object.entries(SEMANTICS)) {
  const parts = chord.split('+');
  const leftParts = parts.filter(p => LEFT_KEY_ORDER.includes(p));
  const rightParts = parts.filter(p => RIGHT_KEY_ORDER.includes(p));
  const normalized = normalizeChordKey(leftParts, rightParts);
  SEMANTICS_LOOKUP[normalized] = data;
}

// Map for getting options for each left key combination
function getOptionsForLeftKeys(leftKeys) {
  const options = {};
  const leftPrefix = sortByOrder(leftKeys, LEFT_KEY_ORDER).join('+');

  for (const [chord, data] of Object.entries(SEMANTICS)) {
    const parts = chord.split('+');
    const chordLeft = sortByOrder(parts.filter(p => LEFT_KEY_ORDER.includes(p)), LEFT_KEY_ORDER).join('+');
    const chordRight = parts.filter(p => RIGHT_KEY_ORDER.includes(p));

    if (chordLeft === leftPrefix) {
      const rightKey = sortByOrder(chordRight, RIGHT_KEY_ORDER).join('+');
      options[rightKey] = data;
    }
  }

  return options;
}

// ============================================================
// CONFIG & STATE
// ============================================================
const API_BASE = 'http://localhost:8000';
let serverOnline = false;

const LEFT_KEYS = { 'c': 4, 'f': 3, 'd': 2, 's': 1, 'a': 0 };
const RIGHT_KEYS = { 'm': 4, 'j': 3, 'k': 2, 'l': 1, ';': 0 };
const LEFT_KEY_CATEGORIES = { 'a': 'action', 's': 'subject', 'd': 'quality', 'f': 'connect', 'c': 'respond' };

const heldKeys = new Set();
const chordBuffer = new Set();
let chordActive = false;
let completedLines = [];
let semanticBuffer = [];
let expanding = false;
let lastExpansionTokens = [];  // For reprompt feature
let lastExpansionResult = '';  // Store last AI output

// DOM elements
const textOutput = document.getElementById('text-output');
const intentDisplay = document.getElementById('intent-display');
const previewResult = document.getElementById('preview-result');
const optionsPanel = document.getElementById('options-panel');
const optionsGrid = document.getElementById('options-grid');

// ============================================================
// CHORD ENGINE
// ============================================================

function isChordKey(key) { return key in LEFT_KEYS || key in RIGHT_KEYS; }

function getLeftCode() {
  let code = 0;
  for (const key of chordBuffer) {
    if (key in LEFT_KEYS) code |= (1 << LEFT_KEYS[key]);
  }
  return code;
}

function getRightCode() {
  let code = 0;
  for (const key of chordBuffer) {
    if (key in RIGHT_KEYS) code |= (1 << RIGHT_KEYS[key]);
  }
  return code;
}

function codeToKeys(code, isLeft) {
  const keys = [];
  const keyMap = isLeft ? ['A', 'S', 'D', 'F', 'C'] : [';', 'L', 'K', 'J', 'M'];
  for (let i = 0; i < 5; i++) {
    if (code & (1 << i)) keys.push(keyMap[i]);
  }
  return keys;
}

function getChordKey(leftCode, rightCode) {
  const leftKeys = codeToKeys(leftCode, true);
  const rightKeys = codeToKeys(rightCode, false);
  if (leftKeys.length === 0 || rightKeys.length === 0) return null;
  return normalizeChordKey(leftKeys, rightKeys);
}

function lookupSemantic(chordKey) {
  return SEMANTICS_LOOKUP[chordKey];
}

function getHeldLeftKeys() {
  const keys = [];
  for (const key of chordBuffer) {
    if (key in LEFT_KEYS) keys.push(key.toUpperCase());
  }
  return sortByOrder(keys, LEFT_KEY_ORDER);
}

function getHeldRightKeys() {
  const keys = [];
  for (const key of chordBuffer) {
    if (key in RIGHT_KEYS) keys.push(key === ';' ? ';' : key.toUpperCase());
  }
  return sortByOrder(keys, RIGHT_KEY_ORDER);
}

function getCurrentCategory() {
  const leftHeld = getHeldLeftKeys();

  // Check for combo categories first
  if (leftHeld.includes('A') && leftHeld.includes('F')) {
    return 'symbol';
  }
  if (leftHeld.includes('D') && leftHeld.includes('C')) {
    return 'style';
  }
  if (leftHeld.includes('S') && leftHeld.includes('C')) {
    return 'mode';
  }

  // Single category
  for (const key of chordBuffer) {
    if (key in LEFT_KEY_CATEGORIES) {
      return LEFT_KEY_CATEGORIES[key];
    }
  }
  return null;
}

// ============================================================
// DISPLAY UPDATES
// ============================================================

function escapeHtml(text) {
  return text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
}

function updateDisplay() {
  let html = '';
  if (completedLines.length > 0) {
    html += completedLines.map(l => escapeHtml(l)).join('\n');
  }
  html += '<span class="cursor"></span>';
  textOutput.innerHTML = html;
  textOutput.scrollTop = textOutput.scrollHeight;

  // Update intent buffer
  if (semanticBuffer.length > 0) {
    intentDisplay.innerHTML = semanticBuffer.map(token =>
      `<span class="intent-token ${token.category}">${token.symbol}</span>`
    ).join('');
  } else {
    intentDisplay.innerHTML = '<span class="intent-placeholder">Hold category key to see options...</span>';
  }
}

function updateKeyVisuals() {
  const leftHeld = getHeldLeftKeys();
  const rightHeld = getHeldRightKeys();
  const category = getCurrentCategory();

  // Check if symbol mode (A+F combo)
  const isSymbolMode = leftHeld.includes('A') && leftHeld.includes('F');

  // Update left hand keys
  document.querySelectorAll('.key.left').forEach(keyEl => {
    const key = keyEl.dataset.key;
    const isPressed = heldKeys.has(key);
    const keyCategory = keyEl.dataset.category;

    keyEl.classList.remove('pressed', 'action', 'subject', 'quality', 'connect', 'respond', 'symbol', 'style', 'mode');

    if (isPressed) {
      if (isSymbolMode) {
        keyEl.classList.add('pressed', 'symbol');
      } else {
        keyEl.classList.add('pressed', keyCategory);
      }
    }
  });

  // Update right hand keys with available options
  const options = leftHeld.length > 0 ? getOptionsForLeftKeys(leftHeld) : {};

  document.querySelectorAll('.key.right').forEach(keyEl => {
    const key = keyEl.dataset.key;
    const keyUpper = key === ';' ? ';' : key.toUpperCase();
    const isPressed = heldKeys.has(key);
    const labelEl = keyEl.querySelector('.key-label');

    keyEl.classList.remove('pressed', 'has-option', 'action', 'subject', 'quality', 'connect', 'respond', 'symbol', 'style', 'mode', 'control');

    // Check for backspace control chord
    if (leftHeld.includes('C') && leftHeld.length === 1 && key === 'm') {
      keyEl.classList.add('has-option', 'control');
      labelEl.textContent = 'BACKSPACE';
      if (isPressed) {
        keyEl.classList.add('pressed', 'control');
      }
      return;
    }

    // Find what this key would produce
    const currentRight = [...rightHeld];
    if (!currentRight.includes(keyUpper)) {
      currentRight.push(keyUpper);
    }
    const rightKey = sortByOrder(currentRight, RIGHT_KEY_ORDER).join('+');

    if (options[rightKey]) {
      const opt = options[rightKey];
      keyEl.classList.add('has-option', opt.category);
      labelEl.textContent = opt.symbol;

      if (isPressed) {
        keyEl.classList.add('pressed', opt.category);
      }
    } else if (key === 'm' && leftHeld.length > 0) {
      // M key always shows "EXTEND" when a category is selected
      keyEl.classList.add('has-option');
      labelEl.textContent = '+MORE';
      labelEl.style.color = 'var(--text-mid)';

      if (isPressed) {
        keyEl.classList.add('pressed');
        keyEl.style.borderColor = 'var(--border-glow)';
      }
    } else {
      labelEl.textContent = '';
      if (isPressed) {
        keyEl.classList.add('pressed');
      }
    }
  });
}

function updatePreview() {
  const leftCode = getLeftCode();
  const rightCode = getRightCode();

  previewResult.classList.remove('action', 'subject', 'quality', 'connect', 'respond', 'symbol', 'style', 'mode', 'control', 'empty');

  if (!chordActive || (leftCode === 0 && rightCode === 0)) {
    previewResult.textContent = 'READY';
    previewResult.classList.add('empty');
    return;
  }

  // Check for control chord (backspace)
  if (leftCode === 16 && rightCode === 16) {
    previewResult.textContent = 'âŒ« BACKSPACE';
    previewResult.classList.add('control');
    return;
  }

  const chordKey = getChordKey(leftCode, rightCode);
  const sem = chordKey ? lookupSemantic(chordKey) : null;
  if (sem) {
    previewResult.textContent = sem.symbol;
    previewResult.classList.add(sem.category);
  } else if (leftCode > 0) {
    const category = getCurrentCategory();
    previewResult.textContent = category ? category.toUpperCase() + '...' : 'SELECT...';
    previewResult.classList.add(category || 'empty');
  } else {
    previewResult.textContent = 'READY';
    previewResult.classList.add('empty');
  }
}

function flashFired() {
  document.querySelectorAll('.key.pressed').forEach(k => {
    k.classList.add('fired');
    setTimeout(() => k.classList.remove('fired'), 200);
  });
}

function flashInvalid() {
  textOutput.classList.add('invalid-flash');
  setTimeout(() => textOutput.classList.remove('invalid-flash'), 300);
}

// ============================================================
// SERVER COMMUNICATION
// ============================================================

async function checkServer() {
  try {
    const res = await fetch(`${API_BASE}/health`, { signal: AbortSignal.timeout(2000) });
    if (res.ok) {
      serverOnline = true;
      document.getElementById('status-dot').classList.add('online');
      document.getElementById('server-status').textContent = 'Connected';
    }
  } catch {
    serverOnline = false;
    document.getElementById('status-dot').classList.remove('online');
    document.getElementById('server-status').textContent = 'Offline';
  }
}

async function expandSemantic(tokens, options = {}) {
  if (!serverOnline) return tokens.map(t => t.symbol).join(' ');
  try {
    const payload = { tokens: tokens.map(t => t.symbol) };

    // Add style modifiers if reprompting
    if (options.styles && options.styles.length > 0) {
      payload.styles = options.styles;
    }
    if (options.originalText) {
      payload.original_text = options.originalText;
    }

    const res = await fetch(`${API_BASE}/expand`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(payload),
      signal: AbortSignal.timeout(15000),
    });
    if (res.ok) {
      const data = await res.json();
      return data.text;
    }
  } catch {
    checkServer();
  }
  return tokens.map(t => t.symbol).join(' ');
}

// ============================================================
// EVENT HANDLERS
// ============================================================

function normalizeKey(e) {
  if (e.key === ';') return ';';
  return e.key.toLowerCase();
}

document.addEventListener('keydown', (e) => {
  if (e.key === ' ') {
    e.preventDefault();
    handleSpace();
    return;
  }

  if (e.key === 'Backspace') {
    e.preventDefault();
    handleBackspace();
    return;
  }

  if (e.key === 'Enter') {
    e.preventDefault();
    handleEnter();
    return;
  }

  const key = normalizeKey(e);
  if (!isChordKey(key)) return;
  e.preventDefault();
  if (expanding) return;
  if (heldKeys.has(key)) return;

  if (!chordActive) {
    chordActive = true;
    chordBuffer.clear();
  }

  heldKeys.add(key);
  chordBuffer.add(key);
  updateKeyVisuals();
  updatePreview();
});

document.addEventListener('keyup', (e) => {
  const key = normalizeKey(e);
  if (!isChordKey(key)) return;
  e.preventDefault();

  heldKeys.delete(key);
  updateKeyVisuals();

  if (chordActive && heldKeys.size === 0) {
    fireChord();
    chordActive = false;
    chordBuffer.clear();
    setTimeout(() => {
      if (!chordActive) {
        updateKeyVisuals();
        updatePreview();
      }
    }, 100);
  }
});

function fireChord() {
  const leftCode = getLeftCode();
  const rightCode = getRightCode();

  // Control: both thumbs = backspace
  if (leftCode === 16 && rightCode === 16) {
    flashFired();
    handleBackspace();
    return;
  }

  const chordKey = getChordKey(leftCode, rightCode);
  const sem = chordKey ? lookupSemantic(chordKey) : null;
  if (sem) {
    flashFired();
    semanticBuffer.push(sem);
    updateDisplay();
  } else if (leftCode > 0 || rightCode > 0) {
    flashInvalid();
  }
}

async function handleSpace() {
  if (semanticBuffer.length === 0) return;
  if (expanding) return;

  expanding = true;
  document.body.classList.add('expanding');
  updateDisplay();

  // Check for REPROMPT in buffer
  const hasReprompt = semanticBuffer.some(t => t.symbol === 'REPROMPT');
  const styleTokens = semanticBuffer.filter(t => t.category === 'style' && t.symbol !== 'REPROMPT');
  const contentTokens = semanticBuffer.filter(t => t.category !== 'style');

  let result;

  if (hasReprompt && lastExpansionTokens.length > 0) {
    // Reprompt: use original tokens with new style modifiers
    result = await expandSemantic(lastExpansionTokens, {
      styles: styleTokens.map(t => t.symbol),
      originalText: lastExpansionResult
    });

    // Replace the last output instead of appending
    if (completedLines.length > 0) {
      // Find and replace the last non-empty line
      for (let i = completedLines.length - 1; i >= 0; i--) {
        if (completedLines[i].trim() !== '') {
          completedLines[i] = result;
          break;
        }
      }
    }
  } else {
    // Normal expansion - include style modifiers if present
    const options = {};
    if (styleTokens.length > 0) {
      options.styles = styleTokens.map(t => t.symbol);
    }
    result = await expandSemantic(contentTokens, options);

    // Store for potential reprompt
    lastExpansionTokens = [...contentTokens];
    lastExpansionResult = result;

    if (completedLines.length > 0 && completedLines[completedLines.length - 1] !== '') {
      completedLines[completedLines.length - 1] += ' ' + result;
    } else if (completedLines.length > 0) {
      completedLines[completedLines.length - 1] = result;
    } else {
      completedLines.push(result);
    }
  }

  expanding = false;
  document.body.classList.remove('expanding');

  semanticBuffer = [];
  updateDisplay();
}

function handleEnter() {
  if (semanticBuffer.length > 0) return;
  completedLines.push('');
  updateDisplay();
}

function handleBackspace() {
  if (expanding) return;
  if (semanticBuffer.length > 0) {
    semanticBuffer.pop();
    updateDisplay();
  } else if (completedLines.length > 0) {
    completedLines.pop();
    updateDisplay();
  }
}

window.addEventListener('blur', () => {
  heldKeys.clear();
  chordBuffer.clear();
  chordActive = false;
  updateKeyVisuals();
  updatePreview();
});

// ============================================================
// INIT
// ============================================================
checkServer();
setInterval(checkServer, 10000);
updateDisplay();
updateKeyVisuals();
updatePreview();
</script>
</body>
</html>
